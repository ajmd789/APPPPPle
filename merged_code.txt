

================================================================================
File: app/src/main/AndroidManifest.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">
    <uses-permission android:name="android.permission.INTERNET" />
    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.APPPPPle"
        tools:targetApi="31">
        
        <activity
            android:name=".ui.bookshelf.BookshelfActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <activity
            android:name=".ui.reader.ReaderActivity"
            android:exported="false"
            android:theme="@style/Theme.APPPPPle.NoActionBar" />

    </application>

</manifest>


================================================================================
File: app/src/main/res/drawable/ic_bookmark.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="#000000"
        android:pathData="M17,3H7C5.9,3 5,3.9 5,5v16l7,-3 7,3V5C19,3.9 18.1,3 17,3z"/>
</vector> 


================================================================================
File: app/src/main/res/drawable/ic_arrow_forward.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="#000000"
        android:pathData="M12,4l-1.41,1.41L16.17,11H4v2h12.17l-5.58,5.59L12,20l8,-8z"/>
</vector> 


================================================================================
File: app/src/main/res/drawable/bg_dialog_catalog.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="@android:color/white"/>
    <corners android:radius="16dp"/>
</shape> 


================================================================================
File: app/src/main/res/drawable/bg_dialog_center_menu.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="@android:color/white"/>
    <corners android:radius="16dp"/>
</shape> 


================================================================================
File: app/src/main/res/drawable/ic_jump.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="#000000"
        android:pathData="M19,3h-4.18C14.4,1.84 13.3,1 12,1c-1.3,0 -2.4,0.84 -2.82,2L5,3c-1.1,0 -2,0.9 -2,2v14c0,1.1 0.9,2 2,2h14c1.1,0 2,-0.9 2,-2L21,5c0,-1.1 -0.9,-2 -2,-2zM12,3c0.55,0 1,0.45 1,1s-0.45,1 -1,1 -1,-0.45 -1,-1 0.45,-1 1,-1zM14,17L7,17v-2h7v2zM17,13L7,13v-2h10v2zM17,9L7,9L7,7h10v2z"/>
</vector> 


================================================================================
File: app/src/main/res/drawable/ic_launcher_foreground.xml

================================================================================

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="85.84757"
                android:endY="92.4963"
                android:startX="42.9492"
                android:startY="49.59793"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
        android:strokeWidth="1"
        android:strokeColor="#00000000" />
</vector>


================================================================================
File: app/src/main/res/drawable/ic_arrow_back.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="#000000"
        android:pathData="M20,11H7.83l5.59,-5.59L12,4l-8,8 8,8 1.41,-1.41L7.83,13H20v-2z"/>
</vector> 


================================================================================
File: app/src/main/res/drawable/skeleton_rect_button.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle">
    <solid android:color="#D1D5DB"/>
    <corners android:radius="16dp"/>
</shape> 


================================================================================
File: app/src/main/res/drawable/bookmark_hint_background.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="#FFFFFF" />
    <corners android:radius="8dp" />
    <stroke
        android:width="1dp"
        android:color="#FF0000" />
</shape> 


================================================================================
File: app/src/main/res/drawable/skeleton_rect.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle">
    <solid android:color="#E0E0E0"/>
    <corners android:radius="8dp"/>
</shape> 


================================================================================
File: app/src/main/res/drawable/ic_launcher_background.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path
        android:fillColor="#3DDC84"
        android:pathData="M0,0h108v108h-108z" />
    <path
        android:fillColor="#00000000"
        android:pathData="M9,0L9,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,0L19,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,0L29,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,0L39,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,0L49,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,0L59,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,0L69,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,0L79,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M89,0L89,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M99,0L99,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,9L108,9"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,19L108,19"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,29L108,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,39L108,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,49L108,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,59L108,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,69L108,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,79L108,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,89L108,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,99L108,99"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,29L89,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,39L89,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,49L89,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,59L89,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,69L89,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,79L89,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,19L29,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,19L39,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,19L49,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,19L59,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,19L69,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,19L79,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
</vector>



================================================================================
File: app/src/main/res/layout/dialog_bookmark_list.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="书签列表"
        android:textSize="20sp"
        android:textStyle="bold"
        android:gravity="center"
        android:layout_marginBottom="16dp"/>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/bookmarkRecyclerView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:maxHeight="400dp"/>

</LinearLayout> 


================================================================================
File: app/src/main/res/layout/dialog_global_search.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp">

    <EditText
        android:id="@+id/searchInput"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="输入搜索关键词"
        android:inputType="text"
        android:imeOptions="actionSearch"/>

    <TextView
        android:id="@+id/resultCount"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:layout_marginBottom="8dp"
        android:textStyle="bold"/>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/searchResults"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"/>

</LinearLayout> 


================================================================================
File: app/src/main/res/layout/activity_bookshelf.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp">

    <TextView
        android:id="@+id/titleTextView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="我的书架"
        android:textSize="24sp"
        android:textStyle="bold"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/booksRecyclerView"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_marginTop="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintTop_toBottomOf="@id/titleTextView" />

    <com.google.android.material.floatingactionbutton.FloatingActionButton
        android:id="@+id/addBookFab"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="16dp"
        android:contentDescription="添加新书"
        android:src="@android:drawable/ic_input_add"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout> 


================================================================================
File: app/src/main/res/layout/item_search_result.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="8dp">

    <TextView
        android:id="@+id/chapterTitle"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textStyle="bold"
        android:textSize="16sp"/>

    <TextView
        android:id="@+id/contentSnippet"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="4dp"
        android:maxLines="2"
        android:ellipsize="end"/>

    <TextView
        android:id="@+id/pageNumber"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="4dp"
        android:textStyle="italic"
        android:textSize="12sp"/>

</LinearLayout> 


================================================================================
File: app/src/main/res/layout/item_catalog.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="12dp"
    android:background="?attr/selectableItemBackground">

    <TextView
        android:id="@+id/chapterTitle"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="16sp"
        android:textColor="?android:attr/textColorPrimary"
        android:maxLines="2"
        android:ellipsize="end"/>

</LinearLayout> 


================================================================================
File: app/src/main/res/layout/bookmark_hint_overlay.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="16dp">

    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="end"
        android:background="@drawable/bookmark_hint_background"
        android:gravity="center_vertical"
        android:orientation="horizontal"
        android:padding="12dp">

        <ImageView
            android:id="@+id/bookmark_icon"
            android:layout_width="24dp"
            android:layout_height="24dp"
            android:src="@drawable/ic_bookmark"
            android:tint="#FF0000" />

        <TextView
            android:id="@+id/bookmark_hint_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="8dp"
            android:text="松手添加书签"
            android:textColor="#FF0000"
            android:textSize="16sp" />

    </LinearLayout>

</FrameLayout> 


================================================================================
File: app/src/main/res/layout/activity_reader.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/contentTextView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_above="@id/bottomControls"
        android:layout_below="@id/topControls"
        android:padding="16dp"
        android:textSize="18sp"
        android:lineSpacingExtra="8dp"
        android:clickable="true"
        android:focusable="true"
        android:background="?attr/selectableItemBackground"/>

    <LinearLayout
        android:id="@+id/topControls"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="8dp"
        android:background="?attr/colorPrimary">

        <TextView
            android:id="@+id/txtProgress"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textColor="@android:color/white"
            android:layout_gravity="center_vertical"/>

        <Space
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"/>

        <ImageButton
            android:id="@+id/btnBookmarks"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:src="@drawable/ic_bookmark"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:tint="@android:color/white"/>
    </LinearLayout>

    <LinearLayout
        android:id="@+id/bottomControls"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:orientation="horizontal"
        android:padding="8dp"
        android:background="?attr/colorPrimary">

        <FrameLayout
            android:id="@+id/prevPageArea"
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:clickable="true"
            android:focusable="true"
            android:background="?attr/selectableItemBackground">

            <ImageButton
                android:id="@+id/btnPrev"
                android:layout_width="72dp"
                android:layout_height="72dp"
                android:layout_gravity="center_vertical|start"
                android:layout_marginStart="16dp"
                android:src="@drawable/ic_arrow_back"
                android:background="?attr/selectableItemBackgroundBorderless"
                android:tint="@android:color/white"
                android:padding="16dp"
                android:contentDescription="上一页"/>
        </FrameLayout>

        <ImageButton
            android:id="@+id/btnJump"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:src="@drawable/ic_jump"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:tint="@android:color/white"/>

        <FrameLayout
            android:id="@+id/nextPageArea"
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:clickable="true"
            android:focusable="true"
            android:background="?attr/selectableItemBackground">

            <ImageButton
                android:id="@+id/btnNext"
                android:layout_width="72dp"
                android:layout_height="72dp"
                android:layout_gravity="center_vertical|end"
                android:layout_marginEnd="16dp"
                android:src="@drawable/ic_arrow_forward"
                android:background="?attr/selectableItemBackgroundBorderless"
                android:tint="@android:color/white"
                android:padding="16dp"
                android:contentDescription="下一页"/>
        </FrameLayout>
    </LinearLayout>

    <FrameLayout
        android:id="@+id/loadingLayout"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="#80000000"
        android:visibility="gone">

        <TextView
            android:id="@+id/loadingText"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:textColor="@android:color/white"
            android:textSize="16sp"/>
    </FrameLayout>

    <View
        android:id="@+id/bookmarkHintOverlay"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="#80000000"
        android:visibility="gone"/>

</RelativeLayout> 


================================================================================
File: app/src/main/res/layout/item_bookmark.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="12dp"
    android:gravity="center_vertical">

    <ImageView
        android:layout_width="24dp"
        android:layout_height="24dp"
        android:src="@drawable/ic_bookmark"
        android:tint="#FF0000" />

    <TextView
        android:id="@+id/bookmarkPageText"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:layout_marginStart="12dp"
        android:textSize="16sp"
        android:text="第 1 页" />

    <ImageButton
        android:id="@+id/btnDeleteBookmark"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_menu_delete"
        android:background="?attr/selectableItemBackgroundBorderless"
        android:padding="8dp" />

</LinearLayout> 


================================================================================
File: app/src/main/res/layout/item_book.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<androidx.cardview.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="8dp"
    app:cardCornerRadius="8dp"
    app:cardElevation="4dp">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="16dp">

        <ImageView
            android:id="@+id/bookCoverImageView"
            android:layout_width="60dp"
            android:layout_height="80dp"
            android:scaleType="centerCrop"
            android:src="@android:drawable/ic_menu_gallery" />

        <LinearLayout
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="16dp"
            android:layout_weight="1"
            android:orientation="vertical">

            <TextView
                android:id="@+id/bookTitleTextView"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="16sp"
                android:textStyle="bold" />

            <TextView
                android:id="@+id/bookProgressTextView"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:textSize="14sp" />

            <TextView
                android:id="@+id/lastReadTimeTextView"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="4dp"
                android:textSize="12sp"
                android:textColor="#666666" />

        </LinearLayout>

    </LinearLayout>

</androidx.cardview.widget.CardView> 


================================================================================
File: app/src/main/res/layout/reader_activity.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp">

    <TextView
        android:id="@+id/txtContent"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:textSize="18sp"
        android:lineSpacingExtra="8dp"
        android:textColor="@android:color/black" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center">

        <Button
            android:id="@+id/btnPrev"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="上一页" />

        <TextView
            android:id="@+id/txtProgress"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginHorizontal="16dp"
            android:textSize="16sp" />

        <Button
            android:id="@+id/btnNext"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="下一页" />
    </LinearLayout>
</LinearLayout> 


================================================================================
File: app/src/main/res/layout/dialog_center_menu.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:background="@drawable/bg_dialog_center_menu"
    android:padding="16dp">

    <Button
        android:id="@+id/btnCatalog"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="目录"
        android:layout_marginBottom="8dp"
        style="@style/Widget.MaterialComponents.Button.OutlinedButton"/>

    <Button
        android:id="@+id/btnSearch"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="搜索"
        style="@style/Widget.MaterialComponents.Button.OutlinedButton"/>

</LinearLayout> 


================================================================================
File: app/src/main/res/layout/activity_main.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"
    android:orientation="vertical">

    <Button
        android:id="@+id/btnSelectBook"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="选择书籍" />

</LinearLayout> 


================================================================================
File: app/src/main/res/layout/dialog_catalog.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:background="@drawable/bg_dialog_catalog">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="目录"
        android:textSize="18sp"
        android:textStyle="bold"
        android:padding="16dp"
        android:background="?attr/colorPrimary"
        android:textColor="@android:color/white"/>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/catalogRecyclerView"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:padding="8dp"/>

</LinearLayout> 


================================================================================
File: app/src/main/res/values-night/themes.xml

================================================================================

<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Theme.APPPPPle" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
        <!-- Primary brand color. -->
        <item name="colorPrimary">@color/purple_200</item>
        <item name="colorPrimaryVariant">@color/purple_700</item>
        <item name="colorOnPrimary">@color/black</item>
        <!-- Secondary brand color. -->
        <item name="colorSecondary">@color/teal_200</item>
        <item name="colorSecondaryVariant">@color/teal_200</item>
        <item name="colorOnSecondary">@color/black</item>
        <!-- Status bar color. -->
        <item name="android:statusBarColor">?attr/colorPrimaryVariant</item>
        <!-- Customize your theme here. -->
    </style>
</resources>


================================================================================
File: app/src/main/res/values/colors.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
    <color name="highlight_color">#FFF59D</color>
</resources>


================================================================================
File: app/src/main/res/values/themes.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Theme.APPPPPle" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
        <!-- Primary brand color. -->
        <item name="colorPrimary">@color/purple_500</item>
        <item name="colorPrimaryVariant">@color/purple_700</item>
        <item name="colorOnPrimary">@color/white</item>
        <!-- Secondary brand color. -->
        <item name="colorSecondary">@color/teal_200</item>
        <item name="colorSecondaryVariant">@color/teal_700</item>
        <item name="colorOnSecondary">@color/black</item>
        <!-- Status bar color. -->
        <item name="android:statusBarColor">?attr/colorPrimaryVariant</item>
        <!-- Customize your theme here. -->
    </style>

    <style name="Theme.APPPPPle.NoActionBar">
        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
    </style>
</resources>


================================================================================
File: app/src/main/res/values/strings.xml

================================================================================

<resources>
    <string name="app_name">APPPPPle</string>
</resources>


================================================================================
File: app/src/main/res/xml/backup_rules.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?><!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older than API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>


================================================================================
File: app/src/main/res/xml/data_extraction_rules.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?><!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>


================================================================================
File: app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>


================================================================================
File: app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml

================================================================================

<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>


================================================================================
File: app/src/main/java/com/example/appppple/ui/MainActivity.java

================================================================================

package com.example.appppple.ui;

import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.util.Log;
import android.widget.Toast;

import androidx.appcompat.app.AppCompatActivity;

import com.example.appppple.R;
import com.example.appppple.domain.parser.BookParser;
import com.example.appppple.domain.parser.ParserFactory;
import com.example.appppple.ui.reader.ReaderActivity;

public class MainActivity extends AppCompatActivity {
    private static final String TAG = "MainActivity";
    private static final int PICK_BOOK_REQUEST = 1;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 启动文件选择器
        Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("*/*"); // 允许选择所有类型的文件
        startActivityForResult(intent, PICK_BOOK_REQUEST);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);

        if (requestCode == PICK_BOOK_REQUEST && resultCode == RESULT_OK) {
            if (data != null && data.getData() != null) {
                Uri uri = data.getData();
                
                try {
                    // 检查文件是否可以被解析
                    BookParser parser = ParserFactory.createParser(this, uri);
                    if (parser == null) {
                        Toast.makeText(this, "不支持的文件格式", Toast.LENGTH_SHORT).show();
                        return;
                    }

                    // 获取文件名
                    String fileName = getFileNameFromUri(uri);
                    if (fileName == null) {
                        Toast.makeText(this, "无法获取文件名", Toast.LENGTH_SHORT).show();
                        return;
                    }

                    // 启动阅读器
                    ReaderActivity.start(this, uri, fileName);
                    finish();
                    
                } catch (Exception e) {
                    Log.e(TAG, "选择文件失败", e);
                    Toast.makeText(this, "选择文件失败: " + e.getMessage(), Toast.LENGTH_SHORT).show();
                }
            } else {
                Toast.makeText(this, "未选择文件", Toast.LENGTH_SHORT).show();
            }
        } else {
            // 用户取消选择或发生错误
            finish();
        }
    }

    private String getFileNameFromUri(Uri uri) {
        String fileName = null;
        
        try {
            // 尝试从 URI 获取文件名
            if (uri.getScheme() != null && uri.getScheme().equals("content")) {
                try (android.database.Cursor cursor = getContentResolver().query(
                        uri, null, null, null, null)) {
                    if (cursor != null && cursor.moveToFirst()) {
                        int nameIndex = cursor.getColumnIndex(android.provider.OpenableColumns.DISPLAY_NAME);
                        if (nameIndex != -1) {
                            fileName = cursor.getString(nameIndex);
                        }
                    }
                }
            }
            
            // 如果无法从 URI 获取，尝试从路径获取
            if (fileName == null) {
                String path = uri.getPath();
                if (path != null) {
                    int lastSlash = path.lastIndexOf('/');
                    if (lastSlash != -1) {
                        fileName = path.substring(lastSlash + 1);
                    }
                }
            }
        } catch (Exception e) {
            Log.e(TAG, "获取文件名失败", e);
        }
        
        return fileName != null ? fileName : "未知文件";
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/ui/reader/CatalogAdapter.java

================================================================================

package com.example.appppple.ui.reader;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import com.example.appppple.R;
import com.example.appppple.domain.model.Chapter;

import java.util.List;

public class CatalogAdapter extends RecyclerView.Adapter<CatalogAdapter.ViewHolder> {
    private final List<Chapter> chapters;
    private final OnChapterClickListener listener;

    public interface OnChapterClickListener {
        void onChapterClick(Chapter chapter);
    }

    public CatalogAdapter(List<Chapter> chapters, OnChapterClickListener listener) {
        this.chapters = chapters;
        this.listener = listener;
    }

    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.item_catalog, parent, false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        Chapter chapter = chapters.get(position);
        holder.bind(chapter);
    }

    @Override
    public int getItemCount() {
        return chapters.size();
    }

    class ViewHolder extends RecyclerView.ViewHolder {
        private final TextView chapterTitle;

        ViewHolder(View itemView) {
            super(itemView);
            chapterTitle = itemView.findViewById(R.id.chapterTitle);

            itemView.setOnClickListener(v -> {
                int position = getAdapterPosition();
                if (position != RecyclerView.NO_POSITION) {
                    listener.onChapterClick(chapters.get(position));
                }
            });
        }

        void bind(Chapter chapter) {
            chapterTitle.setText(chapter.getTitle());
        }
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/ui/reader/ReaderActivity.java

================================================================================

// ui/reader/ReaderActivity.java
package com.example.appppple.ui.reader;

import okhttp3.FormBody;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import android.os.Handler;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.View;
import android.view.animation.AlphaAnimation;
import android.view.animation.Animation;
import android.widget.TextView;
import android.widget.Toast;
import android.app.Dialog;
import android.view.Window;
import android.view.WindowManager;
import android.graphics.Color;
import android.graphics.drawable.ColorDrawable;
import android.text.Editable;
import android.text.TextWatcher;
import android.widget.EditText;

import androidx.appcompat.app.AppCompatActivity;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import androidx.lifecycle.LiveData;
import androidx.lifecycle.MutableLiveData;

import com.example.appppple.R;
import com.example.appppple.domain.manager.BookmarkManager;
import com.example.appppple.domain.manager.ReadingProgressManager;
import com.example.appppple.domain.model.Book;
import com.example.appppple.domain.model.Chapter;
import com.example.appppple.domain.parser.BookParser;
import com.example.appppple.domain.parser.ParserFactory;
import com.example.appppple.domain.parser.TxtParser;
import com.example.appppple.domain.model.Bookmark;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ReaderActivity extends AppCompatActivity {
    private static final int AUTO_SAVE_INTERVAL = 60 * 1000; // 1分钟

    private int lastSavedPage = -1;
    private static final String TAG = "ReaderActivity";
    private static final String EXTRA_BOOK_URI = "book_uri";
    private static final String EXTRA_BOOK_NAME = "book_name";
    private static final int CHARS_PER_PAGE = 1000; // 每页显示的字符数
    private static final float SWIPE_THRESHOLD = 100; // 滑动阈值

    private TextView contentTextView;
    private TextView progressTextView;
    private View loadingLayout;
    private TextView loadingText;
    private View bookmarkHintOverlay;
    private List<String> pages;
    private int currentPage = 0;
    private int totalPages = 0;
    private Book currentBook;
    private ReadingProgressManager progressManager;
    private BookmarkManager bookmarkManager;
    private final ExecutorService executor = Executors.newSingleThreadExecutor();
    private Uri currentBookUri;
    private String currentBookName;
    private GestureDetector gestureDetector;
    private float startY;
    private boolean isBookmarkHintVisible = false;
    private BookmarkAdapter bookmarkAdapter;
    private Dialog bookmarkDialog;
    private Book book;
    private List<Bookmark> bookmarks;

    private Handler autoSaveHandler = new Handler();
    private Runnable autoSaveRunnable = new Runnable() {
        @Override
        public void run() {
            if (currentPage != lastSavedPage) { // 只有页码变化才保存
                saveReadingProgress();
                lastSavedPage = currentPage;
            }
            autoSaveHandler.postDelayed(this, AUTO_SAVE_INTERVAL);
        }
    };

    public static void start(Context context, Uri bookUri, String bookName) {
        Intent intent = new Intent(context, ReaderActivity.class);
        intent.putExtra(EXTRA_BOOK_URI, bookUri);
        intent.putExtra(EXTRA_BOOK_NAME, bookName);
        context.startActivity(intent);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_reader);
        
        initViews();
        initGestureDetector();
        progressManager = ReadingProgressManager.getInstance(this);
        bookmarkManager = BookmarkManager.getInstance(this);

        // 获取传递的书籍信息
        currentBookUri = getIntent().getParcelableExtra(EXTRA_BOOK_URI);
        currentBookName = getIntent().getStringExtra(EXTRA_BOOK_NAME);

        if (currentBookUri == null || currentBookName == null) {
            Toast.makeText(this, "书籍信息不完整", Toast.LENGTH_SHORT).show();
            finish();
            return;
        }

        // 获取文件的持久化权限
        try {
            final int takeFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION
                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;
            getContentResolver().takePersistableUriPermission(currentBookUri, takeFlags);
        } catch (SecurityException e) {
            Log.e(TAG, "获取文件持久化权限失败", e);
            Toast.makeText(this, "无法获取文件访问权限", Toast.LENGTH_SHORT).show();
            finish();
            return;
        }

      

        // 显示加载动画
        showLoading("正在加载书籍...");

        // 异步加载书籍内容
        loadBookContentAsync(currentBookUri, currentBookName);
        autoSaveHandler.postDelayed(autoSaveRunnable, AUTO_SAVE_INTERVAL);
    }




    private void initViews() {
        contentTextView = findViewById(R.id.contentTextView);
        progressTextView = findViewById(R.id.txtProgress);
        loadingLayout = findViewById(R.id.loadingLayout);
        loadingText = findViewById(R.id.loadingText);
        bookmarkHintOverlay = findViewById(R.id.bookmarkHintOverlay);

        // 设置内容区域的触摸监听
        contentTextView.setOnTouchListener((v, event) -> {
            if (gestureDetector != null) {
                gestureDetector.onTouchEvent(event);
            }
            return true;
        });

        // 上一页区域点击处理
        View prevPageArea = findViewById(R.id.prevPageArea);
        prevPageArea.setOnClickListener(v -> {
            Log.d(TAG, "上一页区域被点击");
            if (currentPage > 0) {
                Log.d(TAG, String.format("从第 %d 页翻到第 %d 页", currentPage + 1, currentPage));
                currentPage--;
                updatePageDisplay();
            } else {
                Log.d(TAG, "已经是第一页，无法继续向前翻页");
            }
        });

        // 下一页区域点击处理
        View nextPageArea = findViewById(R.id.nextPageArea);
        nextPageArea.setOnClickListener(v -> {
            Log.d(TAG, "下一页区域被点击");
            if (currentPage < totalPages - 1) {
                Log.d(TAG, String.format("从第 %d 页翻到第 %d 页", currentPage + 1, currentPage + 2));
                currentPage++;
                updatePageDisplay();
            } else {
                Log.d(TAG, "已经是最后一页，无法继续向后翻页");
            }
        });

        // 上一页按钮点击处理
        findViewById(R.id.btnPrev).setOnClickListener(v -> {
            Log.d(TAG, "上一页按钮被点击");
            if (currentPage > 0) {
                Log.d(TAG, String.format("从第 %d 页翻到第 %d 页", currentPage + 1, currentPage));
                currentPage--;
                updatePageDisplay();
                saveReadingProgress();
            } else {
                Log.d(TAG, "已经是第一页，无法继续向前翻页");
            }
        });

        // 下一页按钮点击处理
        findViewById(R.id.btnNext).setOnClickListener(v -> {
            Log.d(TAG, "下一页按钮被点击");
            if (currentPage < totalPages - 1) {
                Log.d(TAG, String.format("从第 %d 页翻到第 %d 页", currentPage + 1, currentPage + 2));
                currentPage++;
                updatePageDisplay();
                saveReadingProgress();
            } else {
                Log.d(TAG, "已经是最后一页，无法继续向后翻页");
            }
        });

        findViewById(R.id.btnJump).setOnClickListener(v -> {
            Log.d(TAG, "跳转按钮被点击");
            showJumpPageDialog();
        });
        
        findViewById(R.id.btnBookmarks).setOnClickListener(v -> {
            Log.d(TAG, "书签按钮被点击");
            showBookmarkListDialog();
        });
    }

    private void initGestureDetector() {
        gestureDetector = new GestureDetector(this, new GestureDetector.SimpleOnGestureListener() {
            private static final int SWIPE_MIN_DISTANCE = 120;
            private static final int SWIPE_THRESHOLD_VELOCITY = 200;

            @Override
            public boolean onDown(MotionEvent e) {
                Log.d(TAG, "onDown: 手势开始");
                return true;
            }

            @Override
            public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
                try {
                    if (e1 == null || e2 == null) {
                        Log.d(TAG, "onFling: 事件为空");
                        return false;
                    }

                    float diffX = e2.getX() - e1.getX();
                    float diffY = e2.getY() - e1.getY();
                    
                    Log.d(TAG, String.format("onFling: diffX=%.2f, diffY=%.2f, velocityX=%.2f, velocityY=%.2f",
                            diffX, diffY, velocityX, velocityY));

                    // 确保水平滑动距离大于垂直滑动距离
                    if (Math.abs(diffX) > Math.abs(diffY)) {
                        // 确保滑动距离足够大
                        if (Math.abs(diffX) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > SWIPE_THRESHOLD_VELOCITY) {
                            if (diffX > 0) {
                                // 向右滑动，显示上一页
                                if (currentPage > 0) {
                                    Log.d(TAG, "onFling: 向右滑动，显示上一页");
                                    currentPage--;
                                    updatePageDisplay();
                                    saveReadingProgress();
                                    return true;
                                }
                            } else {
                                // 向左滑动，显示下一页
                                if (currentPage < totalPages - 1) {
                                    Log.d(TAG, "onFling: 向左滑动，显示下一页");
                                    currentPage++;
                                    updatePageDisplay();
                                    saveReadingProgress();
                                    return true;
                                }
                            }
                        } else {
                            Log.d(TAG, String.format("onFling: 滑动距离或速度不足 - 距离: %.2f, 速度: %.2f",
                                    Math.abs(diffX), Math.abs(velocityX)));
                        }
                    } else {
                        Log.d(TAG, "onFling: 垂直滑动距离大于水平滑动距离");
                    }
                } catch (Exception ex) {
                    Log.e(TAG, "onFling: 手势检测异常", ex);
                }
                return false;
            }

            @Override
            public boolean onSingleTapConfirmed(MotionEvent e) {
                try {
                    // 获取屏幕宽度
                    int screenWidth = getResources().getDisplayMetrics().widthPixels;
                    float x = e.getX();
                    
                    Log.d(TAG, String.format("onSingleTapConfirmed: x=%.2f, screenWidth=%d", x, screenWidth));
                    
                    // 如果点击在屏幕左侧1/3区域，显示上一页
                    if (x < screenWidth / 3) {
                        if (currentPage > 0) {
                            Log.d(TAG, "onSingleTapConfirmed: 点击左侧区域，显示上一页");
                            currentPage--;
                            updatePageDisplay();
                            saveReadingProgress();
                            return true;
                        }
                    }
                    // 如果点击在屏幕右侧1/3区域，显示下一页
                    else if (x > screenWidth * 2 / 3) {
                        if (currentPage < totalPages - 1) {
                            Log.d(TAG, "onSingleTapConfirmed: 点击右侧区域，显示下一页");
                            currentPage++;
                            updatePageDisplay();
                            saveReadingProgress();
                            return true;
                        }
                    }
                    // 如果点击在屏幕中间1/3区域，显示菜单
                    else {
                        Log.d(TAG, "onSingleTapConfirmed: 点击中间区域，显示菜单");
                        showCenterMenu();
                    }
                } catch (Exception ex) {
                    Log.e(TAG, "onSingleTapConfirmed: 点击事件处理异常", ex);
                }
                return true;
            }
        });
    }

    private void showLoading(String message) {
        loadingLayout.setVisibility(View.VISIBLE);
        loadingText.setText(message);
    }

    private void hideLoading() {
        loadingLayout.setVisibility(View.GONE);
    }

    private void loadBookContentAsync(Uri uri, String fileName) {
        executor.execute(() -> {
            try {
                BookParser parser = ParserFactory.createParser(this, uri);
                if (parser == null) {
                    runOnUiThread(() -> {
                        Toast.makeText(this, "不支持的文件格式", Toast.LENGTH_SHORT).show();
                        finish();
                    });
                    return;
                }

                Log.d(TAG, "创建解析器成功: " + parser.getClass().getSimpleName());
                Book book = parser.parse(this, uri);
                if (book == null) {
                    runOnUiThread(() -> {
                        Toast.makeText(this, "解析文件失败", Toast.LENGTH_SHORT).show();
                        finish();
                    });
                    return;
                }

                Log.d(TAG, "解析完成，书籍信息: 标题=" + book.getTitle() + ", 章节数=" + book.getChapters().size());
                book.setUri(uri);
                book.setFileName(fileName);

                // 分页处理
                runOnUiThread(() -> showLoading("正在分页..."));
                this.book = book; // 先设置 book 对象
                book.paginate(CHARS_PER_PAGE, new Book.PaginationListener() {
                    @Override
                    public void onPaginationProgress(int currentPage, int totalPages) {
                        runOnUiThread(() -> {
                            showLoading(String.format("正在分页... %d/%d", currentPage, totalPages));
                        });
                    }

                    @Override
                    public void onPaginationComplete(List<String> pages) {
                        runOnUiThread(() -> {
                            hideLoading();
                            if (pages != null && !pages.isEmpty()) {
                                ReaderActivity.this.pages = pages;
                                totalPages = pages.size();
                                updatePageContent();
                                setupBookmarkObserver();
                            } else {
                                Toast.makeText(ReaderActivity.this, "分页失败：内容为空", Toast.LENGTH_SHORT).show();
                                finish();
                            }
                        });
                    }

                    @Override
                    public void onPaginationError(Exception e) {
                        runOnUiThread(() -> {
                            hideLoading();
                            Toast.makeText(ReaderActivity.this, "分页失败：" + e.getMessage(), Toast.LENGTH_SHORT).show();
                            finish();
                        });
                    }
                });

            } catch (Exception e) {
                Log.e(TAG, "加载书籍失败", e);
                runOnUiThread(() -> {
                    Toast.makeText(this, "加载书籍失败: " + e.getMessage(), Toast.LENGTH_SHORT).show();
                    finish();
                });
            }
        });
    }

    private void setupBookmarkObserver() {
        if (book != null) {
            bookmarkManager.getBookmarksForBook(book.getUri())
                .observe(this, bookmarks -> {
                    if (bookmarks != null) {
                        this.bookmarks = bookmarks;
                        updateBookmarkButton();
                    }
                });
        }
    }

    private void updatePageContent() {
        if (pages == null || pages.isEmpty()) {
            Log.e(TAG, "页面列表为空");
            Toast.makeText(this, "书籍内容为空", Toast.LENGTH_SHORT).show();
            finish();
            return;
        }

        if (currentPage < 0 || currentPage >= pages.size()) {
            Log.e(TAG, "当前页码无效: " + currentPage);
            currentPage = 0;
        }

        contentTextView.setText(pages.get(currentPage));
        progressTextView.setText(String.format("%d/%d", 
            currentPage + 1, 
            totalPages));
        
        // 更新标题显示当前页数
        setTitle(String.format("%s (%d/%d)", book.getTitle(), currentPage + 1, totalPages));

        // 检查当前页是否有书签
        if (book.getUri() != null) {
            bookmarkManager.isBookmarked(book.getUri(), currentPage).observe(this, isBookmarked -> {
                if (isBookmarked) {
                    contentTextView.setCompoundDrawablesWithIntrinsicBounds(0, 0, R.drawable.ic_bookmark, 0);
                } else {
                    contentTextView.setCompoundDrawablesWithIntrinsicBounds(0, 0, 0, 0);
                }
            });
        }
    }

    private void saveReadingProgress() {
        if (book != null && book.getUri() != null) {
            progressManager.saveProgress(book.getFileName(), book.getUri(), currentPage, totalPages)
                .observe(this, success -> {
                    if (success) {
                        Log.d(TAG, String.format("保存阅读进度 - 书名: %s, 当前页: %d/%d",
                                book.getFileName(), currentPage, totalPages));
                    }
                });
        }
    }

    /**
     * 显示跳页对话框
     */
    private void showJumpPageDialog() {
        if (pages == null || pages.isEmpty()) {
            Toast.makeText(this, "书籍内容为空", Toast.LENGTH_SHORT).show();
            return;
        }

        // 创建输入对话框
        androidx.appcompat.app.AlertDialog.Builder builder = new androidx.appcompat.app.AlertDialog.Builder(this);
        builder.setTitle("跳转到指定页");

        // 创建输入框
        final android.widget.EditText input = new android.widget.EditText(this);
        input.setInputType(android.text.InputType.TYPE_CLASS_NUMBER);
        input.setHint(String.format("请输入页码 (1-%d)", totalPages));
        builder.setView(input);

        // 设置按钮
        builder.setPositiveButton("确定", (dialog, which) -> {
            String pageStr = input.getText().toString();
            if (!pageStr.isEmpty()) {
                try {
                    int targetPage = Integer.parseInt(pageStr) - 1; // 转换为0基索引
                    if (targetPage >= 0 && targetPage < totalPages) {
                        currentPage = targetPage;
                        updatePageDisplay();
                        saveReadingProgress();
                    } else {
                        Toast.makeText(this, 
                            String.format("页码必须在1-%d之间", totalPages), 
                            Toast.LENGTH_SHORT).show();
                    }
                } catch (NumberFormatException e) {
                    Toast.makeText(this, "请输入有效的页码", Toast.LENGTH_SHORT).show();
                }
            }
        });
        builder.setNegativeButton("取消", (dialog, which) -> dialog.cancel());

        // 显示对话框
        builder.show();
    }

    private void showBookmarkHint() {
        isBookmarkHintVisible = true;
        bookmarkHintOverlay.setVisibility(View.VISIBLE);
        bookmarkHintOverlay.setAlpha(0f);
        bookmarkHintOverlay.animate()
                .alpha(1f)
                .setDuration(200)
                .start();
    }

    private void hideBookmarkHint() {
        isBookmarkHintVisible = false;
        bookmarkHintOverlay.animate()
                .alpha(0f)
                .setDuration(200)
                .withEndAction(() -> bookmarkHintOverlay.setVisibility(View.GONE))
                .start();
    }

    private void handleBookmarkAction() {
        if (book.getUri() == null || book.getFileName() == null) return;

        bookmarkManager.isBookmarked(book.getUri(), currentPage).observe(this, hasBookmark -> {
            bookmarkManager.toggleBookmark(book.getFileName(), book.getUri(), currentPage)
                .observe(this, success -> {
                    if (success) {
                        Toast.makeText(this, hasBookmark ? "书签已删除" : "书签已添加", Toast.LENGTH_SHORT).show();
                    }
                });
        });
    }

    private void showBookmarkListDialog() {
        if (book.getUri() == null) return;

        bookmarkDialog = new Dialog(this);
        bookmarkDialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
        bookmarkDialog.setContentView(R.layout.dialog_bookmark_list);

        RecyclerView recyclerView = bookmarkDialog.findViewById(R.id.bookmarkRecyclerView);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));

        bookmarkManager.getBookmarksForBook(book.getUri()).observe(this, bookmarks -> {
            bookmarkAdapter = new BookmarkAdapter(bookmarks, new BookmarkAdapter.OnBookmarkClickListener() {
                @Override
                public void onBookmarkClick(Bookmark bookmark) {
                    currentPage = bookmark.getPage();
                    updatePageDisplay();
                    saveReadingProgress();
                    bookmarkDialog.dismiss();
                }

                @Override
                public void onDeleteClick(Bookmark bookmark) {
                    bookmarkManager.toggleBookmark(book.getFileName(), book.getUri(), bookmark.getPage())
                        .observe(ReaderActivity.this, success -> {
                            if (success) {
                                Toast.makeText(ReaderActivity.this, "书签已删除", Toast.LENGTH_SHORT).show();
                            }
                        });
                }
            });

            recyclerView.setAdapter(bookmarkAdapter);
        });

        bookmarkDialog.show();
    }

    private void showCenterMenu() {
        Dialog dialog = new Dialog(this);
        dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
        dialog.setContentView(R.layout.dialog_center_menu);
        
        dialog.findViewById(R.id.btnCatalog).setOnClickListener(v -> {
            dialog.dismiss();
            showCatalogDialog();
        });
        
        dialog.findViewById(R.id.btnSearch).setOnClickListener(v -> {
            dialog.dismiss();
            showSearchDialog();
        });
        
        dialog.show();
    }

    private void showCatalogDialog() {
        if (book == null || book.getChapters() == null) {
            Toast.makeText(this, "目录信息不可用", Toast.LENGTH_SHORT).show();
            return;
        }

        Dialog dialog = new Dialog(this);
        dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
        dialog.setContentView(R.layout.dialog_catalog);

        RecyclerView recyclerView = dialog.findViewById(R.id.catalogRecyclerView);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));

        CatalogAdapter adapter = new CatalogAdapter(book.getChapters(), chapter -> {
            // 计算章节对应的页码
            int targetPage = calculatePageForChapter(chapter);
            if (targetPage >= 0) {
                currentPage = targetPage;
                updatePageDisplay();
                saveReadingProgress();
            }
            dialog.dismiss();
        });

        recyclerView.setAdapter(adapter);
        dialog.show();
    }

    private void showSearchDialog() {
        Dialog dialog = new Dialog(this);
        dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
        dialog.setContentView(R.layout.dialog_global_search);

        EditText searchInput = dialog.findViewById(R.id.searchInput);
        TextView resultCount = dialog.findViewById(R.id.resultCount);
        RecyclerView searchResults = dialog.findViewById(R.id.searchResults);
        searchResults.setLayoutManager(new LinearLayoutManager(this));

        GlobalSearchAdapter adapter = new GlobalSearchAdapter(this);
        searchResults.setAdapter(adapter);

        // 设置搜索监听
        searchInput.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {}

            @Override
            public void afterTextChanged(Editable s) {
                String keyword = s.toString().trim();
                if (keyword.length() > 0) {
                    searchInBook(keyword, adapter, resultCount);
                } else {
                    adapter.clearResults();
                    resultCount.setText("");
                }
            }
        });

        // 设置搜索结果点击事件
        adapter.setOnItemClickListener(result -> {
            currentPage = result.getPageNumber();
            updatePageDisplay();
            saveReadingProgress();
            dialog.dismiss();
        });

        dialog.show();
    }

    private void searchInBook(String keyword, GlobalSearchAdapter adapter, TextView resultCount) {
        if (pages == null || pages.isEmpty()) return;

        List<GlobalSearchAdapter.SearchResult> results = new ArrayList<>();
        for (int i = 0; i < pages.size(); i++) {
            String pageContent = pages.get(i);
            if (pageContent.toLowerCase().contains(keyword.toLowerCase())) {
                // 获取包含关键词的上下文
                int start = Math.max(0, pageContent.toLowerCase().indexOf(keyword.toLowerCase()) - 20);
                int end = Math.min(pageContent.length(), start + 60);
                String snippet = pageContent.substring(start, end);
                if (start > 0) snippet = "..." + snippet;
                if (end < pageContent.length()) snippet = snippet + "...";

                results.add(new GlobalSearchAdapter.SearchResult(
                    "第" + (i + 1) + "页",
                    snippet,
                    i
                ));
            }
        }

        adapter.setResults(results);
        adapter.setKeyword(keyword);
        resultCount.setText(String.format("找到 %d 个结果", results.size()));
    }

    private int calculatePageForChapter(Chapter chapter) {
        if (pages == null || pages.isEmpty()) return -1;

        // 遍历所有页面，查找包含章节标题的页面
        for (int i = 0; i < pages.size(); i++) {
            if (pages.get(i).contains(chapter.getTitle())) {
                return i;
            }
        }
        return -1;
    }

    private void updatePageDisplay() {
        if (pages == null || pages.isEmpty()) {
            Log.e(TAG, "页面列表为空");
            Toast.makeText(this, "书籍内容为空", Toast.LENGTH_SHORT).show();
            finish();
            return;
        }

        if (currentPage < 0 || currentPage >= pages.size()) {
            Log.e(TAG, "当前页码无效: " + currentPage);
            currentPage = 0;
        }

        contentTextView.setText(pages.get(currentPage));
        progressTextView.setText(String.format("%d/%d", 
            currentPage + 1, 
            totalPages));
        
        // 更新标题显示当前页数
        setTitle(String.format("%s (%d/%d)", book.getTitle(), currentPage + 1, totalPages));

        // 检查当前页是否有书签
        if (book.getUri() != null) {
            bookmarkManager.isBookmarked(book.getUri(), currentPage).observe(this, isBookmarked -> {
                if (isBookmarked) {
                    contentTextView.setCompoundDrawablesWithIntrinsicBounds(0, 0, R.drawable.ic_bookmark, 0);
                } else {
                    contentTextView.setCompoundDrawablesWithIntrinsicBounds(0, 0, 0, 0);
                }
            });
        }
    }

    private void updateBookmarkButton() {
        if (bookmarks != null && !bookmarks.isEmpty()) {
            bookmarkAdapter.updateBookmarks(bookmarks);
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        executor.shutdown();
        if (bookmarkDialog != null && bookmarkDialog.isShowing()) {
            bookmarkDialog.dismiss();
        }
        autoSaveHandler.removeCallbacks(autoSaveRunnable);
        
        // 添加保存逻辑
        if (currentPage != lastSavedPage) {
            saveReadingProgress();
        }
        
        sendExitRecord();
    }
    // 新增退出记录方法
    private void sendExitRecord() {
        if (book == null) return;
        
        new Thread(() -> {
            try {
                OkHttpClient client = new OkHttpClient();
                FormBody.Builder formBuilder = new FormBody.Builder()
                    .add("bookName", book.getFileName())
                    .add("currentPage", String.valueOf(currentPage + 1))
                    .add("totalPages", String.valueOf(totalPages))
                    .add("timestamp", String.valueOf(System.currentTimeMillis()));

                Request request = new Request.Builder()
                    .url("http://43.143.236.218:8088/addReadRecord")
                    .post(formBuilder.build())
                    .build();

                client.newCall(request).execute(); // 不需要处理响应
            } catch (Exception e) {
                Log.e(TAG, "发送阅读记录失败", e);
            }
        }).start();
    }
}


================================================================================
File: app/src/main/java/com/example/appppple/ui/reader/GlobalSearchAdapter.java

================================================================================

package com.example.appppple.ui.reader;

import android.content.Context;
import android.text.Spannable;
import android.text.SpannableString;
import android.text.style.BackgroundColorSpan;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import com.example.appppple.R;

import java.util.ArrayList;
import java.util.List;

public class GlobalSearchAdapter extends RecyclerView.Adapter<GlobalSearchAdapter.ViewHolder> {

    private List<SearchResult> searchResults;
    private Context context;
    private OnItemClickListener listener;

    public GlobalSearchAdapter(Context context) {
        this.context = context;
        this.searchResults = new ArrayList<>();
    }

    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_search_result, parent, false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        SearchResult result = searchResults.get(position);
        holder.chapterTitle.setText(result.getChapterTitle());
        holder.contentSnippet.setText(highlightKeyword(result.getContentSnippet(), result.getKeyword()));
        holder.pageNumber.setText(String.format("第 %d 页", result.getPageNumber()));

        holder.itemView.setOnClickListener(v -> {
            if (listener != null) {
                listener.onItemClick(result);
            }
        });
    }

    @Override
    public int getItemCount() {
        return searchResults.size();
    }

    public void setResults(List<SearchResult> results) {
        this.searchResults = results;
        notifyDataSetChanged();
    }

    public void addResults(List<SearchResult> moreResults) {
        int startPosition = this.searchResults.size();
        this.searchResults.addAll(moreResults);
        notifyItemRangeInserted(startPosition, moreResults.size());
    }

    public void clearResults() {
        this.searchResults.clear();
        notifyDataSetChanged();
    }

    public void setKeyword(String keyword) {
        for (SearchResult result : searchResults) {
            result.setKeyword(keyword);
        }
        notifyDataSetChanged();
    }

    private SpannableString highlightKeyword(String content, String keyword) {
        SpannableString spannableString = new SpannableString(content);
        int startIndex = content.toLowerCase().indexOf(keyword.toLowerCase());
        if (startIndex >= 0) {
            spannableString.setSpan(new BackgroundColorSpan(context.getResources().getColor(R.color.highlight_color)),
                    startIndex, startIndex + keyword.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        return spannableString;
    }

    public void setOnItemClickListener(OnItemClickListener listener) {
        this.listener = listener;
    }

    public interface OnItemClickListener {
        void onItemClick(SearchResult result);
    }

    static class ViewHolder extends RecyclerView.ViewHolder {
        TextView chapterTitle;
        TextView contentSnippet;
        TextView pageNumber;

        ViewHolder(View itemView) {
            super(itemView);
            chapterTitle = itemView.findViewById(R.id.chapterTitle);
            contentSnippet = itemView.findViewById(R.id.contentSnippet);
            pageNumber = itemView.findViewById(R.id.pageNumber);
        }
    }

    public static class SearchResult {
        private String chapterTitle;
        private String contentSnippet;
        private int pageNumber;
        private String keyword;

        public SearchResult(String chapterTitle, String contentSnippet, int pageNumber) {
            this.chapterTitle = chapterTitle;
            this.contentSnippet = contentSnippet;
            this.pageNumber = pageNumber;
        }

        public String getChapterTitle() {
            return chapterTitle;
        }

        public String getContentSnippet() {
            return contentSnippet;
        }

        public int getPageNumber() {
            return pageNumber;
        }

        public String getKeyword() {
            return keyword;
        }

        public void setKeyword(String keyword) {
            this.keyword = keyword;
        }
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/ui/reader/ConcurrentPaginator.java

================================================================================

package com.example.appppple.ui.reader;

import android.os.Handler;
import android.os.Looper;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;

/**
 * 支持大文本多线程分块分页、首屏优先渲染的工具类
 * —— 逐行注释版
 */
public class ConcurrentPaginator {

    /**
     * 分块分页完成的回调接口
     */
    public interface OnBlockReadyListener {
        /**
         * 某个块分页完成时回调
         * @param blockIndex  块索引
         * @param pages       当前块分页结果
         * @param isFirstBlock 是否为首屏优先块
         */
        void onBlockReady(int blockIndex, List<String> pages, boolean isFirstBlock);

        /**
         * 全部块分页完成时回调
         * @param allPages 所有页合并后的结果
         */
        void onAllBlocksReady(List<String> allPages);
    }

    // 原始待分页文本
    private final String rawText;
    // 单页字符数
    private final int charsPerPage;
    // 单块分块大小
    private final int blockSize;
    // 线程池线程数
    private final int threadPoolSize;
    // 优先处理块的索引（如首屏/进度块）
    private final int priorityBlockIndex;
    // 分块分页的线程池
    private final ExecutorService executor;
    // 主线程handler，用于回调刷新UI
    private final Handler mainHandler;
    // 每个块分页结果缓存（线程安全）
    private final ConcurrentHashMap<Integer, List<String>> blockPagesMap = new ConcurrentHashMap<>();
    // 块总数
    private int totalBlocks = 0;
    // 已完成块数量
    private volatile int blocksReady = 0;
    // 分块完成回调
    private OnBlockReadyListener blockReadyListener;

    /**
     * 构造方法
     * @param rawText           原始文本
     * @param charsPerPage      单页字符数
     * @param blockSize         单块字符数
     * @param threadPoolSize    线程池大小
     * @param priorityBlockIndex 优先处理块索引
     */
    public ConcurrentPaginator(String rawText, int charsPerPage, int blockSize, int threadPoolSize, int priorityBlockIndex) {
        this.rawText = rawText;
        this.charsPerPage = charsPerPage;
        this.blockSize = blockSize;
        this.threadPoolSize = threadPoolSize;
        this.priorityBlockIndex = priorityBlockIndex;
        this.executor = Executors.newFixedThreadPool(threadPoolSize); // 创建线程池
        this.mainHandler = new Handler(Looper.getMainLooper()); // 主线程handler
    }

    /**
     * 设置分块分页完成的回调
     * @param listener 回调接口
     */
    public void setOnBlockReadyListener(OnBlockReadyListener listener) {
        this.blockReadyListener = listener;
    }

    /**
     * 启动并发分页主流程
     */
    public void startPaging() {
        // 1. 先将原始文本切分成多个块
        List<Block> blocks = splitTextToBlocks(rawText, blockSize);
        totalBlocks = blocks.size();

        // 2. 构建分页任务列表
        List<Future<?>> futures = new ArrayList<>();
        // 2.1 优先提交首屏块任务
        if (priorityBlockIndex >= 0 && priorityBlockIndex < blocks.size()) {
            futures.add(executor.submit(() -> pageBlock(blocks.get(priorityBlockIndex), true)));
        }
        // 2.2 其他块并发提交
        for (int i = 0; i < blocks.size(); i++) {
            if (i == priorityBlockIndex) continue; // 跳过已提交的优先块
            final int idx = i;
            futures.add(executor.submit(() -> pageBlock(blocks.get(idx), false)));
        }

        // 3. 等待所有分页任务完成后，主线程合并最终结果
        executor.submit(() -> {
            try {
                for (Future<?> f : futures) f.get(); // 阻塞直到所有任务完成
                List<String> allPages = collectAllPages(blocks.size());
                // 回调通知全部完成
                if (blockReadyListener != null) {
                    mainHandler.post(() -> blockReadyListener.onAllBlocksReady(allPages));
                }
            } catch (Exception ignored) {}
        });
    }

    /**
     * 对单个块进行分页，并缓存结果
     * @param block         待分页的块
     * @param isFirstBlock  是否为首屏优先块
     */
    private void pageBlock(Block block, boolean isFirstBlock) {
        List<String> pages = new ArrayList<>();
        String text = block.text;
        int len = text.length();
        // 按单页字符数分页
        for (int i = 0; i < len; i += charsPerPage) {
            int end = Math.min(i + charsPerPage, len);
            pages.add(text.substring(i, end));
        }
        // 缓存分页结果
        blockPagesMap.put(block.index, pages);
        blocksReady++;
        // 分块完成回调主线程
        if (blockReadyListener != null) {
            mainHandler.post(() -> blockReadyListener.onBlockReady(block.index, pages, isFirstBlock));
        }
    }

    /**
     * 将原始文本切分为多个块
     * @param text       原始文本
     * @param blockSize  单块大小
     * @return 块列表
     */
    private List<Block> splitTextToBlocks(String text, int blockSize) {
        List<Block> blocks = new ArrayList<>();
        int len = text.length();
        int index = 0;
        for (int i = 0; i < len; i += blockSize) {
            int end = Math.min(i + blockSize, len);
            blocks.add(new Block(index++, text.substring(i, end)));
        }
        return blocks;
    }

    /**
     * 合并所有块的分页结果
     * @param blockCount 块总数
     * @return 合并后的页列表
     */
    private List<String> collectAllPages(int blockCount) {
        List<String> allPages = new ArrayList<>();
        for (int i = 0; i < blockCount; i++) {
            List<String> pages = blockPagesMap.get(i);
            if (pages != null) {
                allPages.addAll(pages);
            }
        }
        return allPages;
    }

    /**
     * 单个块的数据结构
     */
    public static class Block {
        public final int index; // 块索引
        public final String text; // 块内容
        public Block(int index, String text) {
            this.index = index;
            this.text = text;
        }
    }

    /**
     * 停止分页并关闭线程池
     */
    public void shutdown() {
        executor.shutdownNow();
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/ui/reader/BookmarkAdapter.java

================================================================================

package com.example.appppple.ui.reader;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageButton;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import com.example.appppple.R;
import com.example.appppple.domain.model.Bookmark;

import java.util.List;

public class BookmarkAdapter extends RecyclerView.Adapter<BookmarkAdapter.BookmarkViewHolder> {
    private List<Bookmark> bookmarks;
    private final OnBookmarkClickListener listener;

    public interface OnBookmarkClickListener {
        void onBookmarkClick(Bookmark bookmark);
        void onDeleteClick(Bookmark bookmark);
    }

    public BookmarkAdapter(List<Bookmark> bookmarks, OnBookmarkClickListener listener) {
        this.bookmarks = bookmarks;
        this.listener = listener;
    }

    public void updateBookmarks(List<Bookmark> newBookmarks) {
        this.bookmarks = newBookmarks;
        notifyDataSetChanged();
    }

    @NonNull
    @Override
    public BookmarkViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.item_bookmark, parent, false);
        return new BookmarkViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull BookmarkViewHolder holder, int position) {
        Bookmark bookmark = bookmarks.get(position);
        holder.bind(bookmark);
    }

    @Override
    public int getItemCount() {
        return bookmarks.size();
    }

    class BookmarkViewHolder extends RecyclerView.ViewHolder {
        private final TextView bookmarkPageText;
        private final ImageButton deleteButton;

        BookmarkViewHolder(View itemView) {
            super(itemView);
            bookmarkPageText = itemView.findViewById(R.id.bookmarkPageText);
            deleteButton = itemView.findViewById(R.id.btnDeleteBookmark);

            itemView.setOnClickListener(v -> {
                int position = getAdapterPosition();
                if (position != RecyclerView.NO_POSITION) {
                    listener.onBookmarkClick(bookmarks.get(position));
                }
            });

            deleteButton.setOnClickListener(v -> {
                int position = getAdapterPosition();
                if (position != RecyclerView.NO_POSITION) {
                    listener.onDeleteClick(bookmarks.get(position));
                }
            });
        }

        void bind(Bookmark bookmark) {
            bookmarkPageText.setText(String.format("第 %d 页", bookmark.getPage() + 1));
        }
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/ui/reader/PageContextCacheHelper.java

================================================================================

package com.example.appppple.ui.reader;

import android.content.Context;

import java.io.*;
import java.util.ArrayList;
import java.util.List;

/**
 * 支持缓存当前页、总页数及10页上下文的磁盘工具
 */
public class PageContextCacheHelper {

    private static final String CACHE_DIR = "reading_cache";

    /**
     * 保存10页上下文+页码信息到磁盘
     * @param context 应用上下文
     * @param bookId  唯一id
     * @param currentPage 当前页号
     * @param totalPages  总页数
     * @param pageList     10页内容
     */
    public static void savePageContext(Context context, String bookId, int currentPage, int totalPages, List<String> pageList) {
        File dir = new File(context.getFilesDir(), CACHE_DIR);
        if (!dir.exists()) dir.mkdirs();
        File file = new File(dir, bookId + ".cache");
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(file))) {
            // 第一行保存元信息
            bw.write(currentPage + "," + totalPages);
            bw.newLine();
            for (String page : pageList) {
                bw.write(page.replace("\n", "\\n"));
                bw.newLine();
            }
        } catch (IOException e) {
            // 可加日志
        }
    }

    /**
     * 加载缓存，返回[当前页, 总页数, 10页内容]
     */
    public static CacheResult loadPageContext(Context context, String bookId) {
        File dir = new File(context.getFilesDir(), CACHE_DIR);
        File file = new File(dir, bookId + ".cache");
        int currentPage = 0;
        int totalPages = 0;
        List<String> result = new ArrayList<>();
        if (!file.exists()) return new CacheResult(currentPage, totalPages, result);
        try (BufferedReader br = new BufferedReader(new FileReader(file))) {
            String meta = br.readLine();
            if (meta != null && meta.contains(",")) {
                String[] arr = meta.split(",");
                try {
                    currentPage = Integer.parseInt(arr[0]);
                    totalPages = Integer.parseInt(arr[1]);
                } catch (NumberFormatException ignored) {}
            }
            String line;
            while ((line = br.readLine()) != null) {
                result.add(line.replace("\\n", "\n"));
            }
        } catch (IOException e) {
            // 可加日志
        }
        return new CacheResult(currentPage, totalPages, result);
    }

    public static void clearPageContext(Context context, String bookId) {
        File dir = new File(context.getFilesDir(), CACHE_DIR);
        File file = new File(dir, bookId + ".cache");
        if (file.exists()) file.delete();
    }

    public static class CacheResult {
        public final int currentPage;
        public final int totalPages;
        public final List<String> pages;
        public CacheResult(int currentPage, int totalPages, List<String> pages) {
            this.currentPage = currentPage;
            this.totalPages = totalPages;
            this.pages = pages;
        }
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/ui/viewmodel/BookmarkViewModel.java

================================================================================

package com.example.appppple.ui.viewmodel;

import android.app.Application;
import android.net.Uri;

import androidx.annotation.NonNull;
import androidx.lifecycle.AndroidViewModel;
import androidx.lifecycle.LiveData;
import androidx.lifecycle.MediatorLiveData;
import androidx.lifecycle.MutableLiveData;

import com.example.appppple.domain.manager.BookmarkManager;
import com.example.appppple.domain.model.Bookmark;

import java.util.List;

/**
 * 书签 ViewModel
 */
public class BookmarkViewModel extends AndroidViewModel {
    private final BookmarkManager bookmarkManager;
    private final MutableLiveData<List<Bookmark>> currentBookmarks = new MutableLiveData<>();
    private final MutableLiveData<Boolean> currentBookmarkState = new MutableLiveData<>();
    private final MediatorLiveData<List<Bookmark>> allBookmarks = new MediatorLiveData<>();

    public BookmarkViewModel(@NonNull Application application) {
        super(application);
        bookmarkManager = BookmarkManager.getInstance(application);
        allBookmarks.addSource(bookmarkManager.getAllBookmarks(), allBookmarks::setValue);
    }

    /**
     * 获取当前书籍的所有书签
     */
    public void loadBookmarksForBook(Uri bookUri) {
        bookmarkManager.getBookmarksForBook(bookUri).observeForever(currentBookmarks::setValue);
    }

    /**
     * 查询当前页是否有书签
     */
    public void checkBookmarkState(Uri bookUri, int page) {
        bookmarkManager.isBookmarked(bookUri, page).observeForever(currentBookmarkState::setValue);
    }

    /**
     * 添加或删除书签
     */
    public void toggleBookmark(String bookName, Uri bookUri, int page) {
        bookmarkManager.toggleBookmark(bookName, bookUri, page).observeForever(currentBookmarkState::setValue);
    }

    /**
     * 获取当前书籍的书签列表
     */
    public LiveData<List<Bookmark>> getCurrentBookmarks() {
        return currentBookmarks;
    }

    /**
     * 获取当前书签状态
     */
    public LiveData<Boolean> getCurrentBookmarkState() {
        return currentBookmarkState;
    }

    /**
     * 获取所有书签
     */
    public LiveData<List<Bookmark>> getAllBookmarks() {
        return allBookmarks;
    }

    @Override
    protected void onCleared() {
        super.onCleared();
        // 清理观察者
        currentBookmarks.setValue(null);
        currentBookmarkState.setValue(null);
        allBookmarks.setValue(null);
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/ui/viewmodel/ReadingProgressViewModel.java

================================================================================

package com.example.appppple.ui.viewmodel;

import android.app.Application;
import android.net.Uri;

import androidx.annotation.NonNull;
import androidx.lifecycle.AndroidViewModel;
import androidx.lifecycle.LiveData;
import androidx.lifecycle.MediatorLiveData;
import androidx.lifecycle.MutableLiveData;

import com.example.appppple.domain.manager.ReadingProgressManager;
import com.example.appppple.domain.manager.ReadingProgressManager.ReadingProgress;

import java.util.List;

/**
 * 阅读进度 ViewModel
 */
public class ReadingProgressViewModel extends AndroidViewModel {
    private final ReadingProgressManager readingProgressManager;
    private final MutableLiveData<ReadingProgress> currentProgress = new MutableLiveData<>();
    private final MutableLiveData<Boolean> operationResult = new MutableLiveData<>();
    private final MediatorLiveData<List<ReadingProgress>> allProgress = new MediatorLiveData<>();

    public ReadingProgressViewModel(@NonNull Application application) {
        super(application);
        readingProgressManager = ReadingProgressManager.getInstance(application);
        allProgress.addSource(readingProgressManager.getAllReadingProgress(), allProgress::setValue);
    }

    /**
     * 加载当前书籍的阅读进度
     */
    public void loadProgress(Uri bookUri) {
        readingProgressManager.getLastReadingProgress().observeForever(currentProgress::setValue);
    }

    /**
     * 保存阅读进度
     */
    public void saveProgress(String bookName, Uri bookUri, int currentPage, int totalPages) {
        readingProgressManager.saveProgress(bookName, bookUri, currentPage, totalPages)
            .observeForever(operationResult::setValue);
    }

    /**
     * 清除阅读进度
     */
    public void clearProgress(Uri bookUri) {
        readingProgressManager.clearProgress(bookUri).observeForever(operationResult::setValue);
    }

    /**
     * 获取当前阅读进度
     */
    public LiveData<ReadingProgress> getCurrentProgress() {
        return currentProgress;
    }

    /**
     * 获取操作结果
     */
    public LiveData<Boolean> getOperationResult() {
        return operationResult;
    }

    /**
     * 获取所有阅读进度
     */
    public LiveData<List<ReadingProgress>> getAllProgress() {
        return allProgress;
    }

    @Override
    protected void onCleared() {
        super.onCleared();
        // 清理观察者
        currentProgress.setValue(null);
        operationResult.setValue(null);
        allProgress.setValue(null);
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/ui/bookshelf/BookshelfActivity.java

================================================================================

package com.example.appppple.ui.bookshelf;

import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.view.View;

import androidx.appcompat.app.AppCompatActivity;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import com.example.appppple.R;
import com.example.appppple.domain.manager.ReadingProgressManager;
import com.example.appppple.ui.reader.ReaderActivity;
import com.google.android.material.floatingactionbutton.FloatingActionButton;

import java.util.ArrayList;
import java.util.List;

public class BookshelfActivity extends AppCompatActivity {
    private static final int PICK_BOOK_REQUEST = 1;
    private RecyclerView booksRecyclerView;
    private BookAdapter bookAdapter;
    private ReadingProgressManager progressManager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_bookshelf);

        progressManager = ReadingProgressManager.getInstance(this);
        
        initViews();
        loadBooks();
    }

    private void initViews() {
        booksRecyclerView = findViewById(R.id.booksRecyclerView);
        booksRecyclerView.setLayoutManager(new LinearLayoutManager(this));
        bookAdapter = new BookAdapter(new ArrayList<>(), this::onBookClick);
        booksRecyclerView.setAdapter(bookAdapter);

        FloatingActionButton addBookFab = findViewById(R.id.addBookFab);
        addBookFab.setOnClickListener(v -> pickBook());
    }

    private void loadBooks() {
        progressManager.getAllReadingProgress().observe(this, progressList -> {
            bookAdapter.updateBooks(progressList);
        });
    }

    private void onBookClick(ReadingProgressManager.ReadingProgress progress) {
        ReaderActivity.start(this, progress.getBookUri(), progress.getBookName());
    }

    private void pickBook() {
        Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("*/*");
        startActivityForResult(intent, PICK_BOOK_REQUEST);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == PICK_BOOK_REQUEST && resultCode == RESULT_OK && data != null) {
            Uri uri = data.getData();
            if (uri != null) {
                String fileName = getFileNameFromUri(uri);
                ReaderActivity.start(this, uri, fileName);
            }
        }
    }

    private String getFileNameFromUri(Uri uri) {
        String fileName = null;
        try (android.database.Cursor cursor = getContentResolver().query(
                uri, null, null, null, null)) {
            if (cursor != null && cursor.moveToFirst()) {
                int nameIndex = cursor.getColumnIndex(android.provider.OpenableColumns.DISPLAY_NAME);
                if (nameIndex != -1) {
                    fileName = cursor.getString(nameIndex);
                }
            }
        }
        return fileName != null ? fileName : "未知文件";
    }

    @Override
    protected void onResume() {
        super.onResume();
        loadBooks(); // 每次返回书架时刷新列表
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/ui/bookshelf/BookAdapter.java

================================================================================

package com.example.appppple.ui.bookshelf;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import com.example.appppple.R;
import com.example.appppple.domain.manager.ReadingProgressManager;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Locale;

public class BookAdapter extends RecyclerView.Adapter<BookAdapter.BookViewHolder> {
    private List<ReadingProgressManager.ReadingProgress> books;
    private final OnBookClickListener listener;
    private final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm", Locale.getDefault());

    public interface OnBookClickListener {
        void onBookClick(ReadingProgressManager.ReadingProgress progress);
    }

    public BookAdapter(List<ReadingProgressManager.ReadingProgress> books, OnBookClickListener listener) {
        this.books = books;
        this.listener = listener;
    }

    public void updateBooks(List<ReadingProgressManager.ReadingProgress> newBooks) {
        this.books.clear();
        if (newBooks != null) {
            this.books.addAll(newBooks);
        }
        notifyDataSetChanged();
    }

    @NonNull
    @Override
    public BookViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.item_book, parent, false);
        return new BookViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull BookViewHolder holder, int position) {
        ReadingProgressManager.ReadingProgress progress = books.get(position);
        holder.bind(progress);
    }

    @Override
    public int getItemCount() {
        return books.size();
    }

    class BookViewHolder extends RecyclerView.ViewHolder {
        private final ImageView bookCoverImageView;
        private final TextView bookTitleTextView;
        private final TextView bookProgressTextView;
        private final TextView lastReadTimeTextView;

        BookViewHolder(View itemView) {
            super(itemView);
            bookCoverImageView = itemView.findViewById(R.id.bookCoverImageView);
            bookTitleTextView = itemView.findViewById(R.id.bookTitleTextView);
            bookProgressTextView = itemView.findViewById(R.id.bookProgressTextView);
            lastReadTimeTextView = itemView.findViewById(R.id.lastReadTimeTextView);

            itemView.setOnClickListener(v -> {
                int position = getAdapterPosition();
                if (position != RecyclerView.NO_POSITION) {
                    listener.onBookClick(books.get(position));
                }
            });
        }

        void bind(ReadingProgressManager.ReadingProgress progress) {
            bookTitleTextView.setText(progress.getBookName());
            bookProgressTextView.setText(String.format("阅读进度: %d/%d", 
                progress.getCurrentPage() + 1, 
                progress.getTotalPages()));
            lastReadTimeTextView.setText(String.format("上次阅读: %s", 
                dateFormat.format(new Date(progress.getLastReadTime()))));
        }
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/data/AppDatabase.java

================================================================================

package com.example.appppple.data;

import android.content.Context;

import androidx.room.Database;
import androidx.room.Room;
import androidx.room.RoomDatabase;
import androidx.room.TypeConverters;

import com.example.appppple.data.converter.UriConverter;
import com.example.appppple.data.dao.BookmarkDao;
import com.example.appppple.data.dao.ReadingProgressDao;
import com.example.appppple.data.entity.BookmarkEntity;
import com.example.appppple.data.entity.ReadingProgressEntity;

/**
 * 应用数据库
 */
@Database(
    entities = {
        BookmarkEntity.class,
        ReadingProgressEntity.class
    },
    version = 1,
    exportSchema = false
)
@TypeConverters({UriConverter.class})
public abstract class AppDatabase extends RoomDatabase {
    private static final String DATABASE_NAME = "appppple.db";
    private static volatile AppDatabase instance;

    public abstract BookmarkDao bookmarkDao();
    public abstract ReadingProgressDao readingProgressDao();

    public static synchronized AppDatabase getInstance(Context context) {
        if (instance == null) {
            instance = Room.databaseBuilder(
                context.getApplicationContext(),
                AppDatabase.class,
                DATABASE_NAME
            ).build();
        }
        return instance;
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/data/repository/ReadingProgressRepository.java

================================================================================

package com.example.appppple.data.repository;

import android.content.Context;
import android.net.Uri;

import androidx.lifecycle.LiveData;
import androidx.lifecycle.MutableLiveData;

import com.example.appppple.data.AppDatabase;
import com.example.appppple.data.dao.ReadingProgressDao;
import com.example.appppple.data.entity.ReadingProgressEntity;
import com.example.appppple.domain.manager.ReadingProgressManager.ReadingProgress;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 阅读进度仓库
 */
public class ReadingProgressRepository {
    private static ReadingProgressRepository instance;
    private final ReadingProgressDao readingProgressDao;
    private final ExecutorService executorService;

    private ReadingProgressRepository(Context context) {
        readingProgressDao = AppDatabase.getInstance(context).readingProgressDao();
        executorService = Executors.newSingleThreadExecutor();
    }

    public static synchronized ReadingProgressRepository getInstance(Context context) {
        if (instance == null) {
            instance = new ReadingProgressRepository(context.getApplicationContext());
        }
        return instance;
    }

    public LiveData<ReadingProgress> getProgress(Uri bookUri) {
    MutableLiveData<ReadingProgress> result = new MutableLiveData<>();
    executorService.execute(() -> {
        ReadingProgressEntity entity = readingProgressDao.getProgress(bookUri.toString());
        if (entity != null) {
            result.postValue(new ReadingProgress(
                entity.getBookName(),
                entity.getBookUri(),
                entity.getCurrentPage(),
                entity.getTotalPages()
            ));
        } else {
            result.postValue(null);
        }
    });
    return result;
}

    public LiveData<Boolean> saveProgress(String bookName, Uri bookUri, int currentPage, int totalPages) {
        MutableLiveData<Boolean> result = new MutableLiveData<>();
        executorService.execute(() -> {
            try {
                // 先删除旧的阅读进度
                readingProgressDao.deleteProgress(bookUri.toString());

                // 然后插入新的阅读进度
                ReadingProgressEntity entity = new ReadingProgressEntity(
                    bookName,
                    bookUri,
                    currentPage,
                    totalPages
                );
                readingProgressDao.insert(entity);
                result.postValue(true);
            } catch (Exception e) {
                result.postValue(false);
            }
        });
        return result;
    }

    public LiveData<List<ReadingProgress>> getAllProgress() {
        MutableLiveData<List<ReadingProgress>> result = new MutableLiveData<>();
        executorService.execute(() -> {
            List<ReadingProgressEntity> entities = readingProgressDao.getAllProgress();
            List<ReadingProgress> progressList = new ArrayList<>();
            for (ReadingProgressEntity entity : entities) {
                progressList.add(new ReadingProgress(
                    entity.getBookName(),
                    entity.getBookUri(),
                    entity.getCurrentPage(),
                    entity.getTotalPages()
                ));
            }
            result.postValue(progressList);
        });
        return result;
    }

    public LiveData<ReadingProgress> getLastProgress() {
        MutableLiveData<ReadingProgress> result = new MutableLiveData<>();
        executorService.execute(() -> {
            ReadingProgressEntity entity = readingProgressDao.getLastProgress();
            if (entity != null) {
                result.postValue(new ReadingProgress(
                    entity.getBookName(),
                    entity.getBookUri(),
                    entity.getCurrentPage(),
                    entity.getTotalPages()
                ));
            } else {
                result.postValue(null);
            }
        });
        return result;
    }

    public LiveData<Boolean> clearProgress(Uri bookUri) {
        MutableLiveData<Boolean> result = new MutableLiveData<>();
        executorService.execute(() -> {
            try {
                readingProgressDao.deleteProgress(bookUri.toString());
                result.postValue(true);
            } catch (Exception e) {
                result.postValue(false);
            }
        });
        return result;
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/data/repository/BookmarkRepository.java

================================================================================

package com.example.appppple.data.repository;

import android.content.Context;
import android.net.Uri;

import androidx.lifecycle.LiveData;
import androidx.lifecycle.MutableLiveData;

import com.example.appppple.data.AppDatabase;
import com.example.appppple.data.dao.BookmarkDao;
import com.example.appppple.data.entity.BookmarkEntity;
import com.example.appppple.domain.model.Bookmark;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 书签仓库
 */
public class BookmarkRepository {
    private static BookmarkRepository instance;
    private final BookmarkDao bookmarkDao;
    private final ExecutorService executorService;

    private BookmarkRepository(Context context) {
        bookmarkDao = AppDatabase.getInstance(context).bookmarkDao();
        executorService = Executors.newSingleThreadExecutor();
    }

    public static synchronized BookmarkRepository getInstance(Context context) {
        if (instance == null) {
            instance = new BookmarkRepository(context.getApplicationContext());
        }
        return instance;
    }

    public LiveData<List<Bookmark>> getBookmarksForBook(Uri bookUri) {
        MutableLiveData<List<Bookmark>> result = new MutableLiveData<>();
        executorService.execute(() -> {
            List<BookmarkEntity> entities = bookmarkDao.getBookmarksForBook(bookUri.toString());
            List<Bookmark> bookmarks = new ArrayList<>();
            for (BookmarkEntity entity : entities) {
                bookmarks.add(new Bookmark(
                    entity.getBookName(),
                    entity.getBookUri(),
                    entity.getPage(),
                    entity.getTimestamp()
                ));
            }
            result.postValue(bookmarks);
        });
        return result;
    }

    public LiveData<Boolean> isBookmarked(Uri bookUri, int page) {
        MutableLiveData<Boolean> result = new MutableLiveData<>();
        executorService.execute(() -> {
            BookmarkEntity entity = bookmarkDao.getBookmark(bookUri.toString(), page);
            result.postValue(entity != null);
        });
        return result;
    }

    public LiveData<Boolean> toggleBookmark(String bookName, Uri bookUri, int page) {
        MutableLiveData<Boolean> result = new MutableLiveData<>();
        executorService.execute(() -> {
            BookmarkEntity entity = bookmarkDao.getBookmark(bookUri.toString(), page);
            if (entity != null) {
                bookmarkDao.delete(entity);
                result.postValue(false);
            } else {
                entity = new BookmarkEntity(bookName, bookUri, page, System.currentTimeMillis());
                bookmarkDao.insert(entity);
                result.postValue(true);
            }
        });
        return result;
    }

    public LiveData<List<Bookmark>> getAllBookmarks() {
        MutableLiveData<List<Bookmark>> result = new MutableLiveData<>();
        executorService.execute(() -> {
            List<BookmarkEntity> entities = bookmarkDao.getAllBookmarks();
            List<Bookmark> bookmarks = new ArrayList<>();
            for (BookmarkEntity entity : entities) {
                bookmarks.add(new Bookmark(
                    entity.getBookName(),
                    entity.getBookUri(),
                    entity.getPage(),
                    entity.getTimestamp()
                ));
            }
            result.postValue(bookmarks);
        });
        return result;
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/data/converter/UriConverter.java

================================================================================

package com.example.appppple.data.converter;

import androidx.room.TypeConverter;

import android.net.Uri;

/**
 * Uri 类型转换器
 */
public class UriConverter {
    @TypeConverter
    public static String fromUri(Uri uri) {
        return uri == null ? null : uri.toString();
    }

    @TypeConverter
    public static Uri toUri(String uriString) {
        return uriString == null ? null : Uri.parse(uriString);
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/data/entity/ReadingProgressEntity.java

================================================================================

package com.example.appppple.data.entity;

import androidx.room.Entity;
import androidx.room.PrimaryKey;
import androidx.room.TypeConverters;

import com.example.appppple.data.converter.UriConverter;

/**
 * 阅读进度实体类
 */
@Entity(tableName = "reading_progress")
public class ReadingProgressEntity {
    @PrimaryKey(autoGenerate = true)
    private long id;
    
    private String bookName;
    
    @TypeConverters(UriConverter.class)
    private android.net.Uri bookUri;
    
    private int currentPage;
    private int totalPages;
    private long lastReadTime;

    public ReadingProgressEntity(String bookName, android.net.Uri bookUri, int currentPage, int totalPages) {
        this.bookName = bookName;
        this.bookUri = bookUri;
        this.currentPage = currentPage;
        this.totalPages = totalPages;
        this.lastReadTime = System.currentTimeMillis();
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getBookName() {
        return bookName;
    }

    public void setBookName(String bookName) {
        this.bookName = bookName;
    }

    public android.net.Uri getBookUri() {
        return bookUri;
    }

    public void setBookUri(android.net.Uri bookUri) {
        this.bookUri = bookUri;
    }

    public int getCurrentPage() {
        return currentPage;
    }

    public void setCurrentPage(int currentPage) {
        this.currentPage = currentPage;
    }

    public int getTotalPages() {
        return totalPages;
    }

    public void setTotalPages(int totalPages) {
        this.totalPages = totalPages;
    }

    public long getLastReadTime() {
        return lastReadTime;
    }

    public void setLastReadTime(long lastReadTime) {
        this.lastReadTime = lastReadTime;
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/data/entity/BookmarkEntity.java

================================================================================

package com.example.appppple.data.entity;

import androidx.room.Entity;
import androidx.room.PrimaryKey;
import androidx.room.TypeConverters;

import com.example.appppple.data.converter.UriConverter;

/**
 * 书签实体类
 */
@Entity(tableName = "bookmarks")
public class BookmarkEntity {
    @PrimaryKey(autoGenerate = true)
    private long id;
    
    private String bookName;
    
    @TypeConverters(UriConverter.class)
    private android.net.Uri bookUri;
    
    private int page;
    private long timestamp;

    public BookmarkEntity(String bookName, android.net.Uri bookUri, int page, long timestamp) {
        this.bookName = bookName;
        this.bookUri = bookUri;
        this.page = page;
        this.timestamp = timestamp;
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getBookName() {
        return bookName;
    }

    public void setBookName(String bookName) {
        this.bookName = bookName;
    }

    public android.net.Uri getBookUri() {
        return bookUri;
    }

    public void setBookUri(android.net.Uri bookUri) {
        this.bookUri = bookUri;
    }

    public int getPage() {
        return page;
    }

    public void setPage(int page) {
        this.page = page;
    }

    public long getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(long timestamp) {
        this.timestamp = timestamp;
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/data/dao/ReadingProgressDao.java

================================================================================

package com.example.appppple.data.dao;

import androidx.room.Dao;
import androidx.room.Delete;
import androidx.room.Insert;
import androidx.room.OnConflictStrategy;
import androidx.room.Query;
import androidx.room.Update;

import com.example.appppple.data.entity.ReadingProgressEntity;

import java.util.List;

/**
 * 阅读进度数据访问对象
 */
@Dao
public interface ReadingProgressDao {
    @Query("SELECT * FROM reading_progress WHERE bookUri = :bookUri")
    ReadingProgressEntity getProgress(String bookUri);

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    long insert(ReadingProgressEntity progress);

    @Update
    void update(ReadingProgressEntity progress);

    @Delete
    void delete(ReadingProgressEntity progress);

    @Query("DELETE FROM reading_progress WHERE bookUri = :bookUri")
    void deleteProgress(String bookUri);

    @Query("SELECT * FROM reading_progress ORDER BY lastReadTime DESC")
    List<ReadingProgressEntity> getAllProgress();

    @Query("SELECT * FROM reading_progress ORDER BY lastReadTime DESC LIMIT 1")
    ReadingProgressEntity getLastProgress();
} 


================================================================================
File: app/src/main/java/com/example/appppple/data/dao/BookmarkDao.java

================================================================================

package com.example.appppple.data.dao;

import androidx.room.Dao;
import androidx.room.Delete;
import androidx.room.Insert;
import androidx.room.OnConflictStrategy;
import androidx.room.Query;
import androidx.room.Update;

import com.example.appppple.data.entity.BookmarkEntity;

import java.util.List;

/**
 * 书签数据访问对象
 */
@Dao
public interface BookmarkDao {
    @Query("SELECT * FROM bookmarks WHERE bookUri = :bookUri")
    List<BookmarkEntity> getBookmarksForBook(String bookUri);

    @Query("SELECT * FROM bookmarks WHERE bookUri = :bookUri AND page = :page")
    BookmarkEntity getBookmark(String bookUri, int page);

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    long insert(BookmarkEntity bookmark);

    @Update
    void update(BookmarkEntity bookmark);

    @Delete
    void delete(BookmarkEntity bookmark);

    @Query("DELETE FROM bookmarks WHERE bookUri = :bookUri AND page = :page")
    void deleteBookmark(String bookUri, int page);

    @Query("SELECT * FROM bookmarks ORDER BY timestamp DESC")
    List<BookmarkEntity> getAllBookmarks();
} 


================================================================================
File: app/src/main/java/com/example/appppple/domain/pagination/PaginationManager.java

================================================================================

// domain/pagination/PaginationManager.java
package com.example.appppple.domain.pagination;

import android.graphics.Paint;
import android.text.TextPaint;
import android.text.TextUtils;

import java.util.ArrayList;
import java.util.List;

/**
 * 文本分页管理器
 */
public class PaginationManager {
    private final TextPaint mPaint;
    private final int mPageWidth;
    private final int mPageHeight;
    private final float mLineSpacingExtra;
    private final float mLineSpacingMultiplier;

    public PaginationManager(TextPaint paint, int pageWidth, int pageHeight) {
        this(paint, pageWidth, pageHeight, 0, 1.0f);
    }

    public PaginationManager(TextPaint paint, int pageWidth, int pageHeight, 
                           float lineSpacingExtra, float lineSpacingMultiplier) {
        this.mPaint = paint;
        this.mPageWidth = pageWidth;
        this.mPageHeight = pageHeight;
        this.mLineSpacingExtra = lineSpacingExtra;
        this.mLineSpacingMultiplier = lineSpacingMultiplier;
    }

    /**
     * 将文本分页
     * @param text 要分页的文本
     * @return 分页后的文本列表
     */
    public List<String> paginate(String text) {
        if (TextUtils.isEmpty(text)) {
            return new ArrayList<>();
        }

        List<String> pages = new ArrayList<>();
        StringBuilder currentPage = new StringBuilder();
        float currentHeight = 0;
        float lineHeight = mPaint.getFontMetrics(null) * mLineSpacingMultiplier + mLineSpacingExtra;

        // 按行分割文本
        String[] lines = text.split("\n");
        for (String line : lines) {
            // 如果当前行是空行，直接添加
            if (line.trim().isEmpty()) {
                currentPage.append("\n");
                currentHeight += lineHeight;
                continue;
            }

            // 测量当前行的宽度
            float lineWidth = mPaint.measureText(line);
            
            // 如果行宽度超过页面宽度，需要换行
            if (lineWidth > mPageWidth) {
                // 计算每行可以容纳的字符数
                int charsPerLine = (int) (mPageWidth / mPaint.measureText("中")); // 使用中文字符作为基准
                
                // 将长行分割成多行
                int start = 0;
                while (start < line.length()) {
                    int end = Math.min(start + charsPerLine, line.length());
                    String subLine = line.substring(start, end);
                    
                    // 检查是否需要换页
                    if (currentHeight + lineHeight > mPageHeight) {
                        pages.add(currentPage.toString());
                        currentPage = new StringBuilder();
                        currentHeight = 0;
                    }
                    
                    currentPage.append(subLine).append("\n");
                    currentHeight += lineHeight;
                    start = end;
                }
            } else {
                // 检查是否需要换页
                if (currentHeight + lineHeight > mPageHeight) {
                    pages.add(currentPage.toString());
                    currentPage = new StringBuilder();
                    currentHeight = 0;
                }
                
                currentPage.append(line).append("\n");
                currentHeight += lineHeight;
            }
        }

        // 添加最后一页
        if (currentPage.length() > 0) {
            pages.add(currentPage.toString());
        }

        return pages;
    }
}


================================================================================
File: app/src/main/java/com/example/appppple/domain/parser/EpubParser.java

================================================================================

// domain/parser/EpubParser.java
package com.example.appppple.domain.parser;

import android.content.Context;
import android.net.Uri;
import android.util.Log;

import com.example.appppple.domain.model.Book;
import com.example.appppple.domain.model.Chapter;

import org.jsoup.Jsoup;
import nl.siegmann.epublib.domain.TOCReference;
import nl.siegmann.epublib.domain.Resource;
import nl.siegmann.epublib.epub.EpubReader;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

/**
 * EPUB文件解析器
 */
public class EpubParser implements BookParser {
    private static final String TAG = "EpubParser";
    private static final int BUFFER_SIZE = 8192; // 8KB 缓冲区
    private static final long MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB 最大文件大小

    @Override
    public Book parse(Context context, Uri uri) throws IOException, SecurityException, IllegalArgumentException {
        if (context == null) {
            throw new IllegalArgumentException("Context 不能为空");
        }
        if (uri == null) {
            throw new IllegalArgumentException("URI 不能为空");
        }

        // 检查文件大小
        checkFileSize(context, uri);

        // 使用Epub库解析
        nl.siegmann.epublib.domain.Book epubBook;
        EpubReader epubReader = new EpubReader();
        try (InputStream inputStream = context.getContentResolver().openInputStream(uri)) {
            if (inputStream == null) {
                throw new IOException("无法打开文件流");
            }
            epubBook = epubReader.readEpub(inputStream);
        } catch (IOException e) {
            Log.e(TAG, "解析 EPUB 文件失败", e);
            throw new IOException("解析 EPUB 文件失败: " + e.getMessage());
        }
        
        if (epubBook == null) {
            throw new IOException("EPUB 文件解析失败");
        }
        
        Book book = new Book();
        book.setTitle(epubBook.getTitle() != null ? epubBook.getTitle() : "未知标题");
        
        // 解析章节
        List<Chapter> chapters = new ArrayList<>();
        if (epubBook.getTableOfContents() != null) {
            for (TOCReference tocRef : epubBook.getTableOfContents().getTocReferences()) {
                if (tocRef != null) {
                    try {
                        String title = tocRef.getTitle() != null ? tocRef.getTitle() : "未知章节";
                        String content = parseEpubContent(tocRef.getResource());
                        Chapter chapter = new Chapter(title, content);
                        chapters.add(chapter);
                    } catch (IOException e) {
                        Log.e(TAG, "解析章节失败: " + tocRef.getTitle(), e);
                        // 继续处理其他章节
                    }
                }
            }
        }
        book.setChapters(chapters);
        return book;
    }
    
    private String parseEpubContent(Resource resource) throws IOException {
        if (resource == null) {
            return "";
        }
        
        StringBuilder content = new StringBuilder();
        try (InputStream inputStream = resource.getInputStream()) {
            byte[] buffer = new byte[BUFFER_SIZE];
            int bytesRead;
            
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                content.append(new String(buffer, 0, bytesRead, resource.getInputEncoding()));
            }
        }
        
        return Jsoup.parse(content.toString()).text();
    }

    @Override
    public String[] getSupportedMimeTypes() {
        return new String[]{"application/epub+zip"};
    }

    @Override
    public boolean canParse(Context context, Uri uri) {
        if (context == null || uri == null) {
            return false;
        }
        
        try {
            String mimeType = context.getContentResolver().getType(uri);
            return mimeType != null && mimeType.equals("application/epub+zip");
        } catch (Exception e) {
            Log.e(TAG, "检查文件类型失败", e);
            return false;
        }
    }

    /**
     * 检查文件大小是否超过限制
     */
    private void checkFileSize(Context context, Uri uri) throws IOException {
        try (InputStream inputStream = context.getContentResolver().openInputStream(uri)) {
            if (inputStream == null) {
                throw new IOException("无法打开文件流");
            }
            
            long fileSize = 0;
            byte[] buffer = new byte[BUFFER_SIZE];
            int bytesRead;
            
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                fileSize += bytesRead;
                if (fileSize > MAX_FILE_SIZE) {
                    throw new IOException("文件大小超过限制（50MB）");
                }
            }
        }
    }
}


================================================================================
File: app/src/main/java/com/example/appppple/domain/parser/TxtParser.java

================================================================================

package com.example.appppple.domain.parser;

import android.content.Context;
import android.net.Uri;
import android.util.Log;

import com.example.appppple.domain.model.Book;
import com.example.appppple.domain.model.Chapter;
import org.mozilla.universalchardet.UniversalDetector;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * TXT 文件解析器
 */
public class TxtParser implements BookParser {
    private static final String TAG = "TxtParser";
    private static final int BUFFER_SIZE = 8192; // 8KB 缓冲区
    private static final long MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB 最大文件大小
    private static final String DEFAULT_ENCODING = "UTF-8";
    private static final int CHUNK_SIZE = 1024 * 1024; // 1MB 分块大小
    private static final ExecutorService executor = Executors.newSingleThreadExecutor();

    private final List<ChunkLoadListener> chunkLoadListeners = new ArrayList<>();

    public interface ChunkLoadListener {
        void onChunkLoaded(int loadedBytes, int totalBytes);
        void onLoadComplete();
        void onLoadError(Exception e);
    }

    public void addChunkLoadListener(ChunkLoadListener listener) {
        chunkLoadListeners.add(listener);
    }

    public void removeChunkLoadListener(ChunkLoadListener listener) {
        chunkLoadListeners.remove(listener);
    }

    /**
     * 输出当前内存使用情况
     */
    private void logMemoryUsage(String stage) {
        Runtime runtime = Runtime.getRuntime();
        long totalMemory = runtime.totalMemory();
        long freeMemory = runtime.freeMemory();
        long usedMemory = totalMemory - freeMemory;
        long maxMemory = runtime.maxMemory();
        
        Log.d(TAG, String.format("内存使用情况 [%s] - 已用: %.2fMB, 空闲: %.2fMB, 总分配: %.2fMB, 最大可用: %.2fMB",
                stage,
                usedMemory / (1024.0 * 1024.0),
                freeMemory / (1024.0 * 1024.0),
                totalMemory / (1024.0 * 1024.0),
                maxMemory / (1024.0 * 1024.0)));
    }

    @Override
    public Book parse(Context context, Uri uri) throws IOException, SecurityException, IllegalArgumentException {
        if (context == null) {
            throw new IllegalArgumentException("Context 不能为空");
        }
        if (uri == null) {
            throw new IllegalArgumentException("URI 不能为空");
        }

        Log.d(TAG, "开始解析文件: " + uri.toString());

        // 检查文件大小
        checkFileSize(context, uri);

        Book book = new Book();
        String fileName = getFileNameFromUri(context, uri);
        book.setTitle(fileName.replace(".txt", ""));
        
        List<Chapter> chapters = new ArrayList<>();
        
        try (InputStream inputStream = context.getContentResolver().openInputStream(uri)) {
            if (inputStream == null) {
                throw new IOException("无法打开文件流");
            }
            
            // 读取前 4KB 用于编码检测
            byte[] sampleBytes = new byte[4096];
            int sampleSize = inputStream.read(sampleBytes);
            if (sampleSize <= 0) {
                throw new IOException("文件为空");
            }

            // 检测文件编码
            String encoding = detectEncoding(sampleBytes);
            Log.d(TAG, "检测到的文件编码: " + encoding);

            // 使用检测到的编码创建 InputStreamReader
            InputStreamReader reader = new InputStreamReader(
                new java.io.SequenceInputStream(
                    new java.io.ByteArrayInputStream(sampleBytes, 0, sampleSize),
                    inputStream
                ),
                Charset.forName(encoding)
            );

            // 使用 StringBuilder 构建内容
            StringBuilder contentBuilder = new StringBuilder();
            char[] buffer = new char[BUFFER_SIZE];
            int charsRead;
            long totalCharsRead = 0;
            long lastMemoryLogBytes = 0;

            while ((charsRead = reader.read(buffer)) != -1) {
                contentBuilder.append(buffer, 0, charsRead);
                totalCharsRead += charsRead;

                // 每读取 1MB 输出一次内存信息
                if (totalCharsRead - lastMemoryLogBytes >= CHUNK_SIZE) {
                    logMemoryUsage("读取中 - 已读取: " + (totalCharsRead / (1024 * 1024)) + "MB");
                    lastMemoryLogBytes = totalCharsRead;
                    
                    // 通知分块加载进度
                    for (ChunkLoadListener listener : chunkLoadListeners) {
                        listener.onChunkLoaded((int) totalCharsRead, (int) inputStream.available());
                    }
                }
            }

            // 输出读取完成后的内存使用情况
            logMemoryUsage("文件读取完成");

            String content = contentBuilder.toString();
            if (content.isEmpty()) {
                throw new IOException("文件内容为空");
            }

            // 将整个文件内容作为一个章节
            Chapter chapter = new Chapter("正文", content);
            chapters.add(chapter);
            book.setChapters(chapters);
            
            // 通知加载完成
            for (ChunkLoadListener listener : chunkLoadListeners) {
                listener.onLoadComplete();
            }
            
        } catch (IOException e) {
            Log.e(TAG, "解析 TXT 文件失败", e);
            for (ChunkLoadListener listener : chunkLoadListeners) {
                listener.onLoadError(e);
            }
            throw new IOException("解析 TXT 文件失败: " + e.getMessage());
        }
        
        return book;
    }

    /**
     * 使用 juniversalchardet 检测文件编码
     */
    private String detectEncoding(byte[] content) {
        UniversalDetector detector = new UniversalDetector(null);
        
        // 处理文件内容
        detector.handleData(content, 0, content.length);
        detector.dataEnd();
        
        String encoding = detector.getDetectedCharset();
        detector.reset();
        
        if (encoding == null) {
            Log.w(TAG, "无法检测文件编码，使用默认编码: " + DEFAULT_ENCODING);
            return DEFAULT_ENCODING;
        }
        
        // 确保返回的编码名称是有效的
        try {
            Charset.forName(encoding);
            return encoding;
        } catch (Exception e) {
            Log.w(TAG, "检测到的编码 " + encoding + " 无效，使用默认编码", e);
            return DEFAULT_ENCODING;
        }
    }

    @Override
    public String[] getSupportedMimeTypes() {
        return new String[]{"text/plain"};
    }

    @Override
    public boolean canParse(Context context, Uri uri) {
        if (context == null || uri == null) {
            return false;
        }
        
        try {
            String mimeType = context.getContentResolver().getType(uri);
            return mimeType != null && mimeType.equals("text/plain");
        } catch (Exception e) {
            Log.e(TAG, "检查文件类型失败", e);
            return false;
        }
    }

    /**
     * 检查文件大小是否超过限制
     */
    private void checkFileSize(Context context, Uri uri) throws IOException {
        try (InputStream inputStream = context.getContentResolver().openInputStream(uri)) {
            if (inputStream == null) {
                throw new IOException("无法打开文件流");
            }
            
            long fileSize = 0;
            byte[] buffer = new byte[BUFFER_SIZE];
            int bytesRead;
            
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                fileSize += bytesRead;
                if (fileSize > MAX_FILE_SIZE) {
                    throw new IOException("文件大小超过限制（50MB）");
                }
            }
        }
    }

    /**
     * 从 URI 中获取文件名
     */
    private String getFileNameFromUri(Context context, Uri uri) {
        String fileName = null;
        
        try {
            // 尝试从 URI 获取文件名
            if (uri.getScheme() != null && uri.getScheme().equals("content")) {
                try (android.database.Cursor cursor = context.getContentResolver().query(
                        uri, null, null, null, null)) {
                    if (cursor != null && cursor.moveToFirst()) {
                        int nameIndex = cursor.getColumnIndex(android.provider.OpenableColumns.DISPLAY_NAME);
                        if (nameIndex != -1) {
                            fileName = cursor.getString(nameIndex);
                        }
                    }
                }
            }
            
            // 如果无法从 URI 获取，尝试从路径获取
            if (fileName == null) {
                String path = uri.getPath();
                if (path != null) {
                    int lastSlash = path.lastIndexOf('/');
                    if (lastSlash != -1) {
                        fileName = path.substring(lastSlash + 1);
                    }
                }
            }
        } catch (Exception e) {
            Log.e(TAG, "获取文件名失败", e);
        }
        
        return fileName != null ? fileName : "未知文件";
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/domain/parser/BookParser.java

================================================================================

package com.example.appppple.domain.parser;

import android.content.Context;
import android.net.Uri;

import com.example.appppple.domain.model.Book;

import java.io.IOException;

/**
 * 书籍解析器接口
 */
public interface BookParser {
    /**
     * 解析书籍文件
     * @param context 上下文
     * @param uri 文件 URI
     * @return 解析后的书籍对象
     * @throws IOException 如果解析过程中发生 IO 错误
     * @throws SecurityException 如果没有文件访问权限
     * @throws IllegalArgumentException 如果文件格式不正确
     */
    Book parse(Context context, Uri uri) throws IOException, SecurityException, IllegalArgumentException;

    /**
     * 获取解析器支持的文件类型
     * @return 支持的文件类型数组
     */
    String[] getSupportedMimeTypes();

    /**
     * 检查文件是否可以被解析
     * @param context 上下文
     * @param uri 文件 URI
     * @return 是否支持解析
     */
    boolean canParse(Context context, Uri uri);
} 


================================================================================
File: app/src/main/java/com/example/appppple/domain/parser/ParserFactory.java

================================================================================

package com.example.appppple.domain.parser;

import android.content.Context;
import android.net.Uri;
import android.webkit.MimeTypeMap;
import android.util.Log;

import java.io.IOException;
import java.io.InputStream;

/**
 * 解析器工厂类
 */
public class ParserFactory {
    private static final String TAG = "ParserFactory";
    private static final int BUFFER_SIZE = 8192; // 8KB 缓冲区
    private static final long MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB 最大文件大小

    /**
     * 根据文件类型创建对应的解析器
     * @param context 上下文
     * @param uri 文件 URI
     * @return 对应的解析器实例
     * @throws IllegalArgumentException 如果文件类型不支持
     * @throws IOException 如果文件大小超过限制
     */
    public static BookParser createParser(Context context, Uri uri) throws IOException {
        if (context == null) {
            throw new IllegalArgumentException("Context 不能为空");
        }
        if (uri == null) {
            throw new IllegalArgumentException("URI 不能为空");
        }

        // 检查文件大小
        checkFileSize(context, uri);

        String mimeType = getMimeType(context, uri);
        if (mimeType == null) {
            throw new IllegalArgumentException("无法获取文件类型");
        }

        switch (mimeType) {
            case "application/epub+zip":
                return new EpubParser();
            case "text/plain":
                return new TxtParser();
            default:
                throw new IllegalArgumentException("不支持的文件类型: " + mimeType);
        }
    }

    /**
     * 获取文件的 MIME 类型
     * @param context 上下文
     * @param uri 文件 URI
     * @return MIME 类型
     */
    private static String getMimeType(Context context, Uri uri) {
        String mimeType = null;
        
        try {
            // 尝试从 URI 获取 MIME 类型
            if (uri.getScheme() != null && uri.getScheme().equals("content")) {
                mimeType = context.getContentResolver().getType(uri);
            }
            
            // 如果无法从 URI 获取，尝试从文件扩展名获取
            if (mimeType == null) {
                String extension = MimeTypeMap.getFileExtensionFromUrl(uri.toString());
                if (extension != null) {
                    mimeType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension.toLowerCase());
                }
            }
        } catch (Exception e) {
            Log.e(TAG, "获取 MIME 类型失败", e);
        }
        
        return mimeType;
    }

    /**
     * 检查文件大小是否超过限制
     */
    private static void checkFileSize(Context context, Uri uri) throws IOException {
        try (InputStream inputStream = context.getContentResolver().openInputStream(uri)) {
            if (inputStream == null) {
                throw new IOException("无法打开文件流");
            }
            
            long fileSize = 0;
            byte[] buffer = new byte[BUFFER_SIZE];
            int bytesRead;
            
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                fileSize += bytesRead;
                if (fileSize > MAX_FILE_SIZE) {
                    throw new IOException("文件大小超过限制（50MB）");
                }
            }
        }
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/domain/manager/BookmarkManager.java

================================================================================

package com.example.appppple.domain.manager;

import android.content.Context;
import android.net.Uri;
import android.util.Log;

import androidx.lifecycle.LiveData;

import com.example.appppple.data.repository.BookmarkRepository;
import com.example.appppple.domain.model.Bookmark;

import java.util.List;

/**
 * 书签管理器：负责书签的增删查与持久化
 */
public class BookmarkManager {
    private static final String TAG = "BookmarkManager";
    private static BookmarkManager instance;
    private final BookmarkRepository repository;

    private BookmarkManager(Context context) {
        repository = BookmarkRepository.getInstance(context);
    }

    public static BookmarkManager getInstance(Context context) {
        if (instance == null) {
            instance = new BookmarkManager(context.getApplicationContext());
        }
        return instance;
    }

    /**
     * 获取当前书籍的所有书签
     */
    public LiveData<List<Bookmark>> getBookmarksForBook(Uri bookUri) {
        return repository.getBookmarksForBook(bookUri);
    }

    /**
     * 查询当前页是否有书签
     */
    public LiveData<Boolean> isBookmarked(Uri bookUri, int page) {
        return repository.isBookmarked(bookUri, page);
    }

    /**
     * 添加或删除书签：若没有则添加，有则删除（切换效果）
     */
    public LiveData<Boolean> toggleBookmark(String bookName, Uri bookUri, int page) {
        LiveData<Boolean> result = repository.toggleBookmark(bookName, bookUri, page);
        result.observeForever(isAdded -> {
            Log.d(TAG, isAdded ? "添加书签" : "删除书签" + "，页码: " + page);
        });
        return result;
    }

    /**
     * 获取所有书签
     */
    public LiveData<List<Bookmark>> getAllBookmarks() {
        return repository.getAllBookmarks();
    }

} 


================================================================================
File: app/src/main/java/com/example/appppple/domain/manager/UriTypeAdapter.java

================================================================================

package com.example.appppple.domain.manager;

import android.net.Uri;
import android.util.Log;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

import java.lang.reflect.Type;

public class UriTypeAdapter implements JsonSerializer<Uri>, JsonDeserializer<Uri> {
    private static final String TAG = "UriTypeAdapter";

    @Override
    public JsonElement serialize(Uri src, Type typeOfSrc, JsonSerializationContext context) {
        return new JsonPrimitive(src.toString());
    }

    @Override
    public Uri deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
        if (json == null || json.isJsonNull()) {
            return null;
        }
        
        if (json.isJsonPrimitive()) {
            String uriString = json.getAsString();
            return uriString.isEmpty() ? null : Uri.parse(uriString);
        }
        
        if (json.isJsonObject()) {
            JsonObject jsonObject = json.getAsJsonObject();
            if (jsonObject.has("uri")) {
                String uriString = jsonObject.get("uri").getAsString();
                return uriString.isEmpty() ? null : Uri.parse(uriString);
            }
        }
        
        Log.w(TAG, "无法解析 Uri JSON: " + json);
        return null;
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/domain/manager/ReadingProgressManager.java

================================================================================

package com.example.appppple.domain.manager;

import android.content.Context;
import android.net.Uri;
import android.util.Log;

import androidx.lifecycle.LiveData;

import com.example.appppple.data.repository.ReadingProgressRepository;

import java.util.List;

/**
 * 阅读进度管理器
 */
public class ReadingProgressManager {
    private static final String TAG = "ReadingProgressManager";
    private static ReadingProgressManager instance;
    private final ReadingProgressRepository repository;

    private ReadingProgressManager(Context context) {
        repository = ReadingProgressRepository.getInstance(context);
    }

    public LiveData<ReadingProgress> getProgress(Uri bookUri) {
        return repository.getProgress(bookUri);
    }

    public static ReadingProgressManager getInstance(Context context) {
        if (instance == null) {
            instance = new ReadingProgressManager(context.getApplicationContext());
        }
        return instance;
    }

    public static class ReadingProgress {
        private final String bookName;
        private final Uri bookUri;
        private final int currentPage;
        private final int totalPages;
        private final long lastReadTime;

        public ReadingProgress(String bookName, Uri bookUri, int currentPage, int totalPages) {
            this.bookName = bookName;
            this.bookUri = bookUri;
            this.currentPage = currentPage;
            this.totalPages = totalPages;
            this.lastReadTime = System.currentTimeMillis();
        }

        public String getBookName() {
            return bookName;
        }

        public Uri getBookUri() {
            return bookUri;
        }

        public int getCurrentPage() {
            return currentPage;
        }

        public int getTotalPages() {
            return totalPages;
        }

        public long getLastReadTime() {
            return lastReadTime;
        }
    }

    /**
     * 保存阅读进度
     */
    public LiveData<Boolean> saveProgress(String bookName, Uri bookUri, int currentPage, int totalPages) {
        LiveData<Boolean> result = repository.saveProgress(bookName, bookUri, currentPage, totalPages);
        result.observeForever(success -> {
            if (success) {
                Log.d(TAG, String.format("保存阅读进度 - 书名: %s, 当前页: %d/%d", 
                    bookName, currentPage, totalPages));
            }
        });
        return result;
    }

    /**
     * 获取所有阅读进度
     */
    public LiveData<List<ReadingProgress>> getAllReadingProgress() {
        return repository.getAllProgress();
    }

    /**
     * 获取上次阅读的书籍信息
     */
    public LiveData<ReadingProgress> getLastReadingProgress() {
        return repository.getLastProgress();
    }

    /**
     * 清除阅读进度
     */
    public LiveData<Boolean> clearProgress(Uri bookUri) {
        LiveData<Boolean> result = repository.clearProgress(bookUri);
        result.observeForever(success -> {
            if (success) {
                Log.d(TAG, "清除阅读进度: " + bookUri);
            }
        });
        return result;
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/domain/model/Book.java

================================================================================

package com.example.appppple.domain.model;

import android.net.Uri;
import android.util.Log;
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * 书籍模型类
 */
public class Book {
    private static final String TAG = "Book";
    private static final int BUFFER_SIZE = 8192; // 8KB 缓冲区
    private static final ExecutorService executor = Executors.newSingleThreadExecutor();

    private String mTitle;
    private List<Chapter> mChapters;
    private String mAuthor;
    private String mCoverPath;
    private long mLastReadTime;
    private int mLastReadPosition;
    private Uri mUri;
    private String mFileName;
    private List<String> mPages;
    private AtomicInteger mTotalPages;
    private boolean mIsPaginating;

    public interface PaginationListener {
        void onPaginationProgress(int currentPage, int totalPages);
        void onPaginationComplete(List<String> pages);
        void onPaginationError(Exception e);
    }

    public Book() {
        mLastReadTime = System.currentTimeMillis();
        mLastReadPosition = 0;
        mPages = new ArrayList<>();
        mTotalPages = new AtomicInteger(0);
        mIsPaginating = false;
    }

    public String getTitle() {
        return mTitle;
    }

    public void setTitle(String title) {
        this.mTitle = title;
    }

    public List<Chapter> getChapters() {
        return mChapters;
    }

    public void setChapters(List<Chapter> chapters) {
        this.mChapters = chapters;
    }

    public String getAuthor() {
        return mAuthor;
    }

    public void setAuthor(String author) {
        this.mAuthor = author;
    }

    public String getCoverPath() {
        return mCoverPath;
    }

    public void setCoverPath(String coverPath) {
        this.mCoverPath = coverPath;
    }

    public long getLastReadTime() {
        return mLastReadTime;
    }

    public void setLastReadTime(long lastReadTime) {
        this.mLastReadTime = lastReadTime;
    }

    public int getLastReadPosition() {
        return mLastReadPosition;
    }

    public void setLastReadPosition(int lastReadPosition) {
        this.mLastReadPosition = lastReadPosition;
    }

    public Uri getUri() {
        return mUri;
    }

    public void setUri(Uri uri) {
        this.mUri = uri;
    }

    public String getFileName() {
        return mFileName;
    }

    public void setFileName(String fileName) {
        this.mFileName = fileName;
    }

    public List<String> getPages() {
        return mPages;
    }

    public int getTotalPages() {
        return mTotalPages.get();
    }

    public boolean isPaginating() {
        return mIsPaginating;
    }

    /**
     * 获取书籍内容
     * @return 所有章节内容的组合
     */
    public String getContent() {
        if (mChapters == null || mChapters.isEmpty()) {
            return "";
        }

        StringBuilder content = new StringBuilder();
        for (Chapter chapter : mChapters) {
            content.append(chapter.getTitle()).append("\n\n");
            content.append(chapter.getContent()).append("\n\n");
        }
        return content.toString();
    }

    /**
     * 将书籍内容分页
     * @param charsPerPage 每页的字符数
     * @param listener 分页进度监听器
     */
    public void paginate(int charsPerPage, PaginationListener listener) {
        if (charsPerPage <= 0) {
            throw new IllegalArgumentException("每页字符数必须大于0");
        }

        if (mIsPaginating) {
            Log.w(TAG, "分页正在进行中，忽略新的分页请求");
            return;
        }

        mIsPaginating = true;
        executor.execute(() -> {
            try {
                String content = getContent();
                if (content.isEmpty()) {
                    mPages.clear();
                    mTotalPages.set(0);
                    if (listener != null) {
                        listener.onPaginationComplete(mPages);
                    }
                    return;
                }

                List<String> newPages = new ArrayList<>();
                int length = content.length();
                int start = 0;
                int pageCount = 0;

                while (start < length) {
                    int end = Math.min(start + charsPerPage, length);
                    
                    // 如果不是最后一页，尝试在合适的位置分页
                    if (end < length) {
                        // 查找最后一个换行符或空格
                        int lastNewline = content.lastIndexOf('\n', end);
                        int lastSpace = content.lastIndexOf(' ', end);
                        
                        // 选择最接近分页点的位置
                        if (lastNewline > start && lastNewline > lastSpace) {
                            end = lastNewline;
                        } else if (lastSpace > start) {
                            end = lastSpace;
                        }
                    }
                    
                    String page = content.substring(start, end).trim();
                    newPages.add(page);
                    pageCount++;
                    
                    // 每处理10页通知一次进度
                    if (pageCount % 10 == 0 && listener != null) {
                        final int currentPage = pageCount;
                        listener.onPaginationProgress(currentPage, (int) Math.ceil((double) length / charsPerPage));
                    }
                    
                    start = end + 1;
                }

                mPages = newPages;
                mTotalPages.set(pageCount);
                
                if (listener != null) {
                    listener.onPaginationComplete(mPages);
                }
            } catch (Exception e) {
                Log.e(TAG, "分页过程发生错误", e);
                if (listener != null) {
                    listener.onPaginationError(e);
                }
            } finally {
                mIsPaginating = false;
            }
        });
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/domain/model/Bookmark.java

================================================================================

package com.example.appppple.domain.model;

import android.net.Uri;

/**
 * 书签数据模型
 */
public class Bookmark {
    private String bookName;
    private Uri bookUri;
    private int page;
    private long timestamp;

    public Bookmark(String bookName, Uri bookUri, int page, long timestamp) {
        this.bookName = bookName;
        this.bookUri = bookUri;
        this.page = page;
        this.timestamp = timestamp;
    }

    public String getBookName() {
        return bookName;
    }

    public Uri getBookUri() {
        return bookUri;
    }

    public int getPage() {
        return page;
    }

    public long getTimestamp() {
        return timestamp;
    }

    public void setBookName(String bookName) {
        this.bookName = bookName;
    }

    public void setBookUri(Uri bookUri) {
        this.bookUri = bookUri;
    }

    public void setPage(int page) {
        this.page = page;
    }

    public void setTimestamp(long timestamp) {
        this.timestamp = timestamp;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Bookmark)) return false;
        Bookmark other = (Bookmark) obj;
        // 以书籍和页码为唯一性
        return bookUri != null && bookUri.equals(other.bookUri) && page == other.page;
    }

    @Override
    public int hashCode() {
        return (bookUri != null ? bookUri.hashCode() : 0) * 31 + page;
    }
} 


================================================================================
File: app/src/main/java/com/example/appppple/domain/model/Chapter.java

================================================================================

package com.example.appppple.domain.model;

/**
 * 章节模型类
 */
public class Chapter {
    private String mTitle;
    private String mContent;

    public Chapter(String title, String content) {
        this.mTitle = title;
        this.mContent = content;
    }

    public String getTitle() {
        return mTitle;
    }

    public void setTitle(String title) {
        this.mTitle = title;
    }

    public String getContent() {
        return mContent;
    }

    public void setContent(String content) {
        this.mContent = content;
    }

    /**
     * 追加内容
     * @param content 要追加的内容
     */
    public void appendContent(String content) {
        if (mContent == null) {
            mContent = content;
        } else {
            mContent += content;
        }
    }
} 
